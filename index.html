<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>나의 배움 일기</title>
</head>
<body>
  <h1> HTML 1일차 </h1>
  <p> 공부한 자료: <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Basic_HTML_syntax">Mozilla Developer Network 학습자료의 기초 HTML 문법</a> </p>
  <h2> HTML이란 </h2>
  <p> 
    웹페이지의 내용을 적는 문법으로 구성요소(Element)들로 이뤄져있다. 
    구성요소를 적는 문법은 <code> &lt;이름&gt; 내용 &lt;/이름&gt; </code>이다. 
    &lt;&gt; 안에 들어가는 구성요소 이름을 태그라고 부른다. 
  </p>
  <h3> HTML의 구성요소들 </h3>
  <p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p"><code> &lt;p&gt; 내용 &lt;/p&gt;</code></a>
    내용을 한문단(paragraph)으로 묶는다.
  </p>
  <p>
    예제 코드: &lt;p&gt; 첫번째 문단 &lt;/p&gt; &lt;p&gt; 두번째 문단 &lt;/p&gt;
  </p>
  <p> 실행 결과: </p>
  <p> 첫번째 문단 </p>
  <p> 두번째 문단 </p>

  <h1> C 1일차 </h1>
  <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
  <h2> Pi </h2>
  <p> 정보 기술 - 프로그래밍 언어 - C </p>
  <p> 답장을 보낼 메일 주소: JeanHeyd Meneide &lt;wg14@soasis.org&gt; </p>
  <p> Freek Wiedijk &lt;freek@cs.ru.nl&gt; </p>
  <p> 초록 (ISO에 의해 바뀔 예정) </p>
  <p> 본 문서는 프로그래밍 언어 C로 작성된 프로그램의 형식과 번역방식을 정한다. 본 문서의 목적은 다양한 컴퓨터 시스템에서 C 언어 프로그램의 효율적 실행, 유지보수, 안정성, 이식성을 장려하는 것이다. </p>
  <p> C 언어 자체에 대한 세부 내용과, C 언어 실행 라이브러리의 내용이 들어있다. 붙임 문서에서 두 경우를 모두 다루며, C 프로그램의 이식성에 영향을 주는 요소들을 나열한다. </p>
  <p> 본 문서는 C 언어 프로그래머와 C 언어 번역 시스템 개발자들에게 가이드를 제시하려고 하지만, 본 문서 자체가 튜토리얼 기능을 하기 위해 설계되지는 않았다. </p>
  <p> 본 초안을 받은 사람들은 본인이 알고 있는 관련된 특허권에 대해 코멘트와 증빙 서류를 제출할 수 있다. </p>
  <p> C23 사이클이 끝난 뒤에 본 문서의 다음 버전인 "C2y" 작업이 2024년 1월 24일에 시작되었다. </p>
  <p> 2024년 1월 </p>
  <p> 2024년 프랑스 스트라스부르 미팅에서 다음 변경 사항이 반영되었다. </p>
  <p> - N3192: 순서가 있는 16진수 </p>
  <p> - 편집자: 붙임 K의 한 주석에서 "예약됨"을 "예약될 수 있음"으로 변경 </p>
  <p> 2024년 6월 </p>
  <p> 2024 6월 가상 미팅에서 다음과 같은 내용이 변경되었다. </p>
  <p> - N3064: 바이트 여러개로 구성된 문자들로 이뤄진 파일에 쓰기 </p>
  <p> - N3232: 반올림 한 값에서 원래 값 얻기 </p>
  <p> - N3233: printf 반올림 권장 방법 </p>
  <p> - N3239: 값 자체인 상수 버전 2 </p>
  <p> - N3242: "정확한 반올림"을 쓸 때 문제점 </p>
  <p> - N3244: 세속적인 악마들을 물리치기 (6.3.2.1, 6.7.2, 6.7, 6.7.5, 6.7.6 변경) </p>
  <p> - N3247: fopen "p"와 fopen의 모드를 POSIX 202x에 비슷하게 맞추기 </p>
  <p> - N3254: 바이트 배열에 접근하기, 버전 4 </p>
  <p> - N3259: 복소수에서의 ++, -- 지원 </p>
  <p> - N3260: _Generic에서 타입 피연산자를 선택하기 </p>


  <h1> HTML 2일차 </h1>
  <p> 공부한 자료: <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Basic_HTML_syntax">Mozilla Developer Network 학습자료의 기초 HTML 문법</a> </p>
  <h2> 요소 안의 요소 </h2>
  <p> 
    구성요소 안에 구성요소를 적는 문법은 <code> &lt;바깥요소이름&gt; 바깥요소내용1 &lt;안요소이름&gt; 안요소내용 &lt;/안요소이름&gt; 바깥요소내용2 &lt;/바깥요소이름&gt; </code>이다. 
    요소 안에 요소를 계속 추가할 수 있다.
  </p>
  <h2> 속성 </h2>
    <p> 
      속성은 요소에 대한 정보를 주는 것인데, 요소의 내용이 아니어서 보이지는 않는다.  
      <code> &lt;요소이름 속성이름="속성값"&gt; </code> 형식으로 쓴다.  
      속성 문법의 규칙으로, 먼저 속성이름과 요소이름 사이에 띄어쓰기가 있어야 한다. 
      속성 여러개를 쓸 때도 속성들 사이에 띄어쓰기가 있어야 한다.
      속성 이름 다음에 등호 <code> = </code>가 있어야 한다.
      등호 다음에 속성 값이 따옴표 <code> ' ' </code> 또는 <code> " " </code> 안에 있어야 한다. 
    </p>
  <h2> 비어있는 요소 </h2>
    <p> 
      어떤 요소는 안에 들어가는 내용이 없다. 그래서 다음과 같이 태그에 속성만 적고, 닫는 태그와 내용은 쓰지 않아도 된다.
      <code> &lt;요소이름 속성 /&gt; </code>
      HTML에서는 <code>/</code>가 없어도 되지만, XML 문법과의 호환성을 위해 쓰는 것이 좋다. 
    </p>
  <h3> 비어있는 요소와 속성의 예시 </h3>
  <p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img"><code> &lt;img src="그림파일경로" 기타속성="기타속성값" /&gt; </code></a>
    웹페이지에 이미지를 넣는다. 
    src 속성은 반드시 필요하며, 이미지 파일의 경로를 정한다. 
  </p>
  <p>
    예제 코드: &lt;img src="/program.png" /&gt;
  </p>
  <p> 실행 결과: <img src="/program.png" /> </p>
  <p> <code> width </code> 속성은 이미지의 너비를 픽셀 단위로 정한다. </p>
  <p>
    예제 코드: &lt;img src="/program.png" width="300" /&gt;
  </p>
  <p> 실행 결과: <img src="/program.png" width="300" /> </p>
  <p> <code> height </code> 속성은 이미지의 높이를 픽셀 단위로 정한다. </p>
  <p>
    예제 코드: &lt;img src="/program.png" width="300" height="150" /&gt;
  </p>
  <p> 실행 결과: <img src="/program.png" width="300" height="150" /> </p>

  <h1> C 2일차 - C2y standard </h1>
  <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
  <h2> Pii </h2>
  <p> - N3273: 불완전 배열 타입의 alignof </p>
  <p> - N3274: 허수 타입 제거하기 버전 3 </p>
  <p> - 편집자: ISO / IEC 지침에 따라 해야한다(may)를 할수있다(can)으로 변경 </p>
  <p> - 편집자: ISO / IEC 지침에 따라 표 소제목 변경 </p>

  <p> 2024년 9월/10월 </p>
  <p> 2024년 9월/10월 미국 미니애폴리스 미팅 후 다음 변경 사항이 반영되었다. </p>
  <p> - N3272: strftime을 할 때 구조체 내용의 해석 방법 (옵션 1: 정해지지 않음) </p>
  <p> - N3286: 매크로 바꾸기를 할 때 부동소수점 예외 </p>
  <p> - N3287: 수학 관련 규격 문서에서 괄호 위치 오타 </p>
  <p> - N3291: 십진수 부동 소수점 숫자 단어의 잘못된 사용 </p>
  <p> - N3298: 복소수 리터럴 도입 (4.2에서 제안된 내용 배제) </p>
  <p> - N3303: HUGE_VAL 수정 </p>
  <P> - N3305: &lt;math.h&gt;에서 십진 부동소숫점과 관련된 WANT 매크로 삭제 </P>
  <p> - N3312: Atomic의 Alignment 조건을 완화하기 </p>
  <p> - N3322: null에 연산 허용하기, 라이브러리 함수의 인자로 허용하기 </p>
  <p> - N3323: 어떤 것에 1을 더할 때 적절한 타입 쓰기 </p>
  <p> - N3324: "극점-오류" 단어로 고치기 </p>
  <p> - N3326: strnlen 함수와 wcsnlen 함수 추가 </p>
  <p> - N3340: 세속적인 악마들을 물리치기 II </p>
  <p> - N3341: 세속적인 악마들을 물리치기 III </p>
  <p> - N3342: 세속적인 악마들을 물리치기 IV </p>
  <p> - N3344: 세속적인 악마들을 물리치기 VI </p>
  <p> - N3345: 세속적인 악마들을 물리치기 VII </p>
  <p> - N3346: 세속적인 악마들을 물리치기 VIII </p>
  <p> - N3347: 세속적인 악마들을 물리치기 IX </p>
  <p> - N3353: 8진수 리터럴 표기법 변경 </p>
  <p> - N3355: 루프에 라벨링하기 </p>
  <p> - N3356: if에서 선언하기 </p>
  <p> - N3364: SNAN으로 초기화 </p>
  <p> - N3366: 효율적인 문자 인코딩 변환을 위한 재시작 가능 함수 </p>
  <p> - N3367: 더 현대적인 비트 기능들 </p>
  <p> - N3369: _Lengthof 연산자 </p>
  <p> - N3370: switch문에서의 case 범위 </p>

  <h1> C 2일차 - GNU C 언어 매뉴얼 </h1>
  <p> 공부한 자료: <a href="https://www.gnu.org/software/c-intro-and-ref/manual/html_node/index.html">International Standard Organization의 C23 standard</a> </p>
  <h2> 짧은 목차 </h2>
  <p> 1 첫번째 예제 </p>
  <p> 2 완성된 프로그램 </p>
  <p> 3 저장소와 데이터 </p>
  <p> 4 정수를 넘어서 </p>
  <p> 5 단어 규칙 </p>
  <p> 6 산수 </p>
  <p> 7 대입식 </p>
  <p> 8 실행 제어 식 </p>
  <p> 9 이항 연산자 문법 </p>
  <p> 10 실행 순서 </p>
  <p> 11 원시 자료형 </p>
  <p> 12 상수 </p>
  <p> 13 자료형 크기 </p>
  <p> 14 포인터 </p>
  <p> 15 구조체 </p>
  <p> 16 배열 </p>
  <p> 17 열거형 </p>
  <p> 18 자료형 이름 정의 </p>
  <p> 19 문장 </p>
  <p> 20 변수 </p>
  <p> 21 자료형 한정자 </p>
  <p> 22 함수 </p>
  <p> 23 호환되는 자료형 </p>
  <p> 24 형변환 </p>
  <p> 25 유효범위 </p>
  <p> 26 전처리 </p>
  <p> 27 고급 정수 </p>
  <p> 28 고급 부동소수점 </p>
  <p> 29 컴파일 </p>
  <p> 30 컴파일 지시하기 </p>
  <p> 붙임 A 자료형 정렬 </p>
  <p> 붙임 B 메모리 값을 다른 자료형으로 쓰기 </p>
  <p> 붙임 C 별칭 </p>
  <p> 붙임 D 선언에서의 속성 </p>
  <p> 붙임 E 신호 </p>
  <p> 붙임 F GNU 자유 문서 라이선스 </p>
  <p> 붙임 G GNU 일반 공공 라이선스 </p>
  <p> 기호와 키워드 목차 </p>
  <p> 개념 목차 </p>

  <h2> 목차 </h2>
  <p> 1 첫번째 예제 </p>
  <p> 1.1 예제: 재귀적인 피보나치 </p>
  <p> 1.1.1 함수 헤더 </p>
  <p> 1.1.2 함수 바디 </p>
  <p> 1.2 스택, 스택 오버플로우 </p>
  <p> 1.3 예제: 반복적인 피보나치</p>
  <p> 2 완성된 프로그램 </p>
  <p> 2.1 완성된 프로그램 예제 </p>
  <p> 2.2 완성된 프로그램 설명 </p>
  <p> 2.3 완성된 프로그램, 한줄씩 </p>
  <p> 2.4 완성된 프로그램 컴파일하기 </p>
  <p> 3 저장소와 데이터 </p>
  <p> 4 정수를 넘어서 </p>
  <p> 4.1 정수가 아닌 숫자를 쓰는 예제 </p>
  <p> 4.2 배열을 쓰는 예제 </p>
  <p> 4.3 함수 호출에서 배열을 쓰는 예제 </p>
  <p> 4.4 배열을 쓰는 여러 방법 예제 </p>
  <p> 5 단어 규칙 </p>
  <p> 5.1 프로그램을 영어로 쓰기! </p>
  <p> 5.2 문자들 </p>
  <p> 5.3 공백 </p>
  <p> 5.4 주석 </p>
  <p> 5.5 식별자 </p>
  <p> 5.6 연산자와 구두점 </p>
  <p> 5.7 줄 이어쓰기 </p>
  <p> 6 산수 </p>
  <p> 6.1 기초 산수 </p>
  <p> 6.2 정수 산수 </p>
  <p> 6.3 정수 오버플로우 </p>
  <p> 6.3.1 부호 없는 정수의 오버플로우 </p>
  <p> 6.3.2 부호 있는 정수의 오버플로우 </p>
  <p> 6.4 여러 자료형간 산수 </p>
  <p> 6.5 나누기와 나머지 </p>
  <p> 6.6 숫자 비교 </p>
  <p> 6.7 비트 이동 연산자 </p>
  <p> 6.7.1 비트 이동으로 새로운 비트들이 만들어짐 </p>
  <p> 6.7.2 비트 이동에서 지켜야 할 원칙 </p>
  <p> 6.7.3 비트 이동 꿀팁 </p>
  <p> 6.8 비트별 연산 </p>
  <p> 7 대입식 </p>
  <p> 7.1 단순 대입 </p>
  <p> 7.2 왼쪽값 </p>
  <p> 7.3 값을 변경하는 대입 </p>
  <p> 7.4 증가연산자와 감소연산자 </p>
  <p> 7.5 후에 증가시키고 감소시키기 </p>
  <p> 7.6 위험: 식 내부에서 대입할 때 </p>
  <p> 7.7 별개의 문장에서 대입하기 </p>
  <p> 8 실행 제어 식 </p>
  <p> 8.1 논리 연산자 </p>
  <p> 8.2 논리 연산자와 비교 </p>
  <p> 8.3 논리 연산자와 대입 </p>
  <p> 8.4 조건 식 </p>
  <p> 8.4.1 조건 연산자의 규칙 </p>
  <p> 8.4.2 조건 연산자의 갈래들 </p>
  <p> 8.5 쉼표 연산자 </p>
  <p> 8.5.1 쉼표 연산자의 사용 </p>
  <p> 8.5.2 쉼표 연산자의 깔끔한 사용 </p>
  <p> 8.5.3 쉼표 연산자를 쓰지 말아야 할 때 </p>
  <p> 9 이항 연산자 문법 </p>
  <p> 10 실행 순서 </p>
  <p> 10.1 피연산자 순서 바꾸기 </p>
  <p> 10.2 결합 법칙과 순서 </p>
  <p> 10.3 모든 연산이 완료되는 시점 </p>
  <p> 10.4 후에 증가시키는 연산과 순서 </p>
  <p> 10.5 피연산자의 순서 </p>
  <p> 10.6 최적화와 순서 </p>
  <p> 11 원시 자료형 </p>
  <p> 11.1 정수 자료형 </p>
  <p> 11.1.1 기본 정수 </p>
  <p> 11.1.2 부호가 있는 자료형과 부호가 없는 자료형 </p>
  <p> 11.1.3 크기가 작은 정수 </p>
  <p> 11.1.4 정수 자료형 간의 변환 </p>
  <p> 11.1.5 논리 자료형 </p>
  <p> 11.1.6 정수 자료형의 다양성 </p>
  <p> 11.2 부동소수점 자료형 </p>
  <p> 11.3 복소수 자료형 </p>
  <p> 11.4 void형 </p>
  <p> 11.5 기타 자료형 </p>
  <p> 11.6 타입이 정해지는 규칙 </p>

  
  <h1> HTML 3일차 </h1>
  <p> 공부한 자료: <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Basic_HTML_syntax">Mozilla Developer Network 학습자료의 기초 HTML 문법</a> </p>
  <h3> 논리 속성 </h3>
    <p> 논리 속성은 참이나 거짓으로 설정되는 속성이다. 논리 속성을 값 없이 쓰거나, 
      어떤 값이든 넣어서 쓰면 참으로 설정된다. 매뉴얼에서는 값을 비어있는 문자열이나, 
      논리 속성 이름으로 설정하라고 하지만, 다른 값을 넣어도 똑같이 작동한다. 
      반대로 논리 속성을 요소 안에 쓰지 않으면, 해당 논리 속성은 거짓으로 설정된다. 
    </p>
  <h3> 논리 속성이 있는 요소 예시 </h3>
  <p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">
      <code> &lt;input type="입력방법" /&gt; </code>
    </a>
    웹페이지에 입력을 받을 수 있는 요소를 만든다.
  </p>
  <p>
    예제 코드: <code> &lt;input type="text" /&gt; </code>
  </p>
  <p> 실행 결과: <input type="text" /> </p>
  <p> <code> disabled </code> 논리 속성은 값을 변경할 수 없게 한다. </p>
  <p>
    예제 코드: <code> &lt;input type="text" disabled /&gt; </code>
  </p>
  <p> 실행 결과: <input type="text" disabled /> </p>
  <h2> HTML 문서의 구성 </h2>
  <p> HTML 문서는 다음과 같이 구성되어 있다. </p>
  <code><pre>
    &lt;!doctype html&gt;
    &lt;html lang="ko-KR"&gt;
      &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;제목&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;p&gt;내용&lt;/p&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  </pre></code>
  여기서, 

  <ol>
    <li>
      <code>&lt;!doctype html&gt;</code>은 90년대 html 규격 링크를 다는데 쓰였다. 지금은 html 문서임을 정한다.
    </li>
    <li>
      <code>&lt;html&gt;&lt;/html&gt;</code>은 전체 HTML 페이지에 해당하는 요소다. 
    </li>
    <li>
      <code>&lt;head&gt;&lt;/head&gt;</code>는 보여지지 않는 모든 내용을 담는 요소다. 스타일, 쓸 문자들 등이 있다.
    </li>
    <li>
      <code>&lt;meta charset="utf-8" /&gt;</code>는 UTF-8로 인코딩된 문자들을 쓰겠다는 것을 의미한다.
    </li>
    <li>
      <code>&lt;title&gt;&lt;/title&gt;</code>은 페이지의 제목을 설정한다. 
    </li>
    <li>
      <code>&lt;body&gt;&lt;/body&gt;</code>는 페이지에 보이는 모든 것을 담는 요소다. 
    </li>
  </ol>

  <h2> HTML에서 공백문자 </h2>
  <p> 공백 문자를 많이 쓰더라도 띄어쓰기 한칸으로 인식된다. 다음 두 코드는 같은 결과를 보여준다. </p>
  <code><pre>
    &lt;p id="공백없음"&gt; 띄어 쓰기 &lt;/p&gt;

    &lt;p id="공백많음"&gt; 띄어 
          쓰기 &lt;/p&gt;
  </pre></code>

  <h2> HTML에서 특수문자 쓰기 </h2>
  <p> 
    HTML에서 <code><</code>, <code>></code>, <code>"</code>, <code>'</code>, <code>&</code>는 특수문자이다. 
    <code><</code>는 <code>&amp;lt;</code>로, <code>></code>는 <code>&amp;gt;</code>로, 
    <code>"</code>는 <code>&amp;quot;</code>로, <code>'</code>는 <code>&amp;apos;</code>로,
    <code>&</code>는 <code>&amp;amp;</code>로 쓸 수 있다.
  </p>
  <p> 예제 코드: <code>&amp;lt; &amp;amp;lt;</code> </p>
  <p> 실행 결과: <code>&lt; &amp;lt;</code> </p>


  <h2> HTML 주석 </h2>
  <p>
    HTML에서 주석을 쓰려면 <code>&lt;!--</code>와 <code>--&gt;</code> 사이에 쓴다. 
  </p>
  <p> 예제 코드: <code>&lt;p&gt;주석 밖&lt;/p&gt; &lt;!-- &lt;p&gt;주석 안&lt;/p&gt; --&gt;</code> </p>
  <p> 실행 결과: </p>
  <p>주석 밖</p> <!--주석 안-->


  <h1> C 3일차 - C2y standard </h1>
  <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
  <h2> Piii </h2>
  <p> </p>
  <h2> Piv </h2>
  <p> 목차 </p>
  <p> 서문 ... xiv </p>
  <p> 서론 ... xv </p>
  <p> 1 다루는 범위 ... 1 </p>
  <p> 2 참고한 표준 ... 2 </p>
  <p> 3 단어, 정의, 기호 ... 3 </p>
  <p> 4 적합성 ... 9 </p>
  <p> 5 환경 ... 11 </p>
  <p> 5.1 서론 ... 11 </p>
  <p> 5.2 개념적 모델 ... 11 </p>
  <p> 5.2.1 번역 환경 ... 11 </p>
  <p> 5.2.2 실행 환경 ... 12 </p>
  <p> 5.3 환경에서 고려할 점 ... 19 </p>
  <p> 5.3.1 문자셋 ... 19 </p>
  <p> 5.3.2 2바이트 이상의 문자들 ... 20 </p>
  <p> 5.3.3 화면에 문자를 표시할 때 ... 21 </p>
  <p> 5.3.4 신호와 인터럽트 ... 21 </p>
  <p> 5.3.5 환경 관련 제약 ... 21 </p>
  <p> 6. 언어 ... 36 </p>
  <p> 6.1 표기법 ... 36 </p>
  <p> 6.2 개념 ... 36 </p>
  <p> 6.2.1 식별자의 범위, 타입 이름, 복합 리터럴 ... 36 </p>
  <p> 6.2.2 식별자간 링크 ... 37 </p>
  <p> 6.2.3 식별자의 이름 공간 ... 38 </p>
  <p> 6.2.4 객체의 저장 기간 ... 38 </p>
  <p> 6.2.5 자료형 ... 39 </p>
  <p> 6.2.6 자료형이 저장되는 방법 ... 43 </p>
  <p> 6.2.7 호환가능한 자료형과 합성 자료형 ... 44 </p>
  <p> 6.2.8 객체의 정렬 ... 46 </p>
  <p> 6.2.9 인코딩 ... 46 </p>
  <p> 6.3 자료형 변환 ... 47 </p>
  <p> 6.3.1 서론 ... 47 </p>
  <p> 6.3.2 산술 피연산자 ... 47 </p>
  <h2> Pv </h2>
  <p> 6.3.3 기타 피연산자 ... 51 </p>
  <p> 6.4. 단어 구성요소 ... 54 </p>
  <p> 6.4.1 일반 ... 54 </p>
  <p> 6.4.2 키워드 ... 55 </p>
  <p> 6.4.3 식별자 ... 56 </p>
  <p> 6.4.4 국제 문자 ... 58 </p>
  <p> 6.4.5 상수 ... 60 </p>
  <p> 6.4.6 문자열 리터럴 ... 71 </p>
  <p> 6.4.7 구두점 ... 72 </p>
  <p> 6.4.8 헤더 이름 ... 73 </p>
  <p> 6.4.9 전처리 숫자 ... 74 </p>
  <p> 6.4.10 주석 ... 74 </p>
  <p> 6.5 수식 ... 76 </p>
  <p> 6.5.1 일반 ... 76 </p>
  <p> 6.5.2 가장 간단한 식 ... 77 </p>
  <p> 6.5.3 피연산자 뒤에 있는 연산자 ... 79 </p>
  <p> 6.5.4 단항 연산자 ... 86 </p>
  <p> 6.5.5 형변환 연산자 ... 89 </p>
  <p> 6.5.6 곱셈 연산자 ... 89 </p>
  <p> 6.5.7 덧셈 연산자 ... 90 </p>
  <p> 6.5.8 비트 이동 연산자 ... 91 </p>
  <p> 6.5.9 관계 연산자 ... 92 </p>
  <p> 6.5.10 등호 연산자 ... 93 </p>
  <p> 6.5.11 비트별 AND 연산자 ... 94 </p>
  <p> 6.5.12 비트별 XOR 연산자 ... 94 </p>
  <p> 6.5.13 비트별 OR 연산자 ... 94 </p>
  <p> 6.5.14 논리 AND 연산자 ... 94 </p>
  <p> 6.5.15 논리 OR 연산자 ... 95 </p>
  <p> 6.5.16 조건 연산자 ... 95 </p>
  <p> 6.5.17 대입 연산자 ... 96 </p>
  <p> 6.5.18 쉼표 연산자 ... 99 </p>
  <p> 6.6 상수 식 ... 100 </p>
  <p> 6.6.1 상수 범위 식 ... 101 </p>
  <p> 6.7 선언 ... 104 </p>
  <p> 6.7.1 일반 ... 104</p>
  <p> 6.7.2 저장유형 지정자 ... 106 </p>
  <p> 6.7.3 자료형 지정자 ... 110 </p>
  <p> 6.7.4 자료형 한정자 ... 127 </p>
  <p> 6.7.5 함수 한정자 ... 131 </p>
  <p> 6.7.6 정렬 지정자 ... 132 </p>
  <h2> Pvi </h2>
  <p> 6.7.7 선언자 ... 133 </p>
  <p> 6.7.8 자료형 이름 ... 139 </p>
  <p> 6.7.9 자료형 정의 ... 140 </p>
  <p> 6.7.10 자료형 추론 ... 142 </p>
  <p> 6.7.11 초기화 ... 143 </p>
  <p> 6.7.12 정적 확인 ... 149 </p>
  <p> 6.7.13 속성 ... 149 </p>
  <p> 6.8 문장과 블록 ... 160 </p>
  <p> 6.8.1 일반 ... 160 </p>
  <p> 6.8.2 이름붙은 문장 ... 161 </p>
  <p> 6.8.3 합성 문장 ... 161 </p>
  <p> 6.8.4 수식 문장과 null 문장 ... 162 </p>
  <p> 6.8.5 선택 문장 ... 162 </p>
  <p> 6.8.6 반복 문장 ... 165 </p>
  <p> 6.8.7 점프 문장 ... 166 </p>
  <p> 6.9 외부 정의 ... 171 </p>
  <p> 6.9.1 일반 ... 171 </p>
  <p> 6.9.2 함수 정의 ... 171 </p>
  <p> 6.9.3 외부 객체 정의 ... 173 </p>
  <p> 6.10 전처리 지시 ... 175 </p>
  <p> 6.10.1 일반 ... 175 </p>
  <p> 6.10.2 조건부 포함 ... 178 </p>
  <p> 6.10.3 소스 파일 포함 ... 192 </p>
  <p> 6.10.4 이진 파일 포함 ... 183 </p>
  <p> 6.10.5 매크로로 바꾸기 ... 190 </p>
  <p> 6.10.6 줄 제어 ... 197 </p>
  <p> 6.10.7 진단용 지시 ... 198</p>
  <p> 6.10.8 컴파일러 대상 지시 ... 198 </p>
  <p> 6.10.9 null 지시 ... 199 </p>
  <p> 6.10.10 미리 정해진 매크로 이름 ... 199 </p>
  <p> 6.10.11 컴파일러 대상 지시 연산자 ... 201 </p>
  <p> 6.11 미래 발전 방향 ... 203 </p>
  <p> 6.11.1 부동소수점 자료형 ... 203 </p>
  <p> 6.11.2 식별자 링크 ...  203 </p>
  <p> 6.11.3 외부 이름 ... 203 </p>
  <p> 6.11.4 표현하기 어려운 문자 ... 203 </p>
  <p> 6.11.5 저장유형지정자 ... 203 </p>
  <p> 6.11.6 8진수 표기법 ... 203 </p>
  <p> 6.11.7 컴파일러 지시 ... 203 </p>
  <p> 6.11.8 미리 정해진 매크로 이름 ... 203 </p>

  <h1> HTML 4일차 </h1>
  <p> 공부한 자료: 
    <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Webpage_metadata">
      MDN docs -> core learning modules -> HTML -> head
    </a> 
  </p>
  <h2> head와 메타 데이터 </h2>
    <p> 
      head에는 화면에는 보이지 않는 메타데이터가 저장된다. 
      페이지 제목, 그래픽 관련 설정, 탭에 표시되는 아이콘, 키워드 등이 여기에 해당한다. 
    </p>
    <p> 예제 코드: </p>
    <code><pre>
      &lt;!doctype html&gt;
      &lt;html lang="ko-KR"&gt;
        &lt;head&gt;
          &lt;meta charset="utf-8" /&gt;
          &lt;title&gt;제목&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;내용&lt;/p&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre></code>
    <p> 
      여기서, <code>&lt;head&gt;</code> 요소 안에 있는 것들이 HTML head가 된다. 
      head 안에 있는 <code>&lt;title&gt;</code> 요소는 탭에서의 제목, 즐겨찾기의 제목이 된다. 
    </p>

    <h3> 
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta">
        <code> &lt;meta 속성이름="속성값" /&gt;</code>
      </a>
      : 메타 데이터를 공식적으로 HTML 문서에 추가하는 요소
    </h3>

    <p>
      <code> charset </code> 속성은 문서에서 쓸 문자들을 정해준다. 
      <code> utf-8 </code>은 세계 대부분 나라의 문자를 표현할 수 있고, 한글도 표현가능하다. 
      <code> ISO-8859-1 </code>은 영어와 라틴 문자들만 표현할 수 있고, 한글은 깨진다. 
    </p>

    <p> 예제 코드: <code>&lt;meta charset="utf-8" /&gt;</code></p> 
    <p> 실행 결과: <code>utf-8</code>의 문자들 사용 가능 </p>

    <p>
      <code> name </code> 속성과 <code> contents </code> 속성을 지정하는 방식으로
      어떤 종류의 메타데이터가 무엇이라고 정할 수 있다.
    </p>


    <h1> Windows API 1일차 </h1>
    <h2> 윈도우 창 만들기 </h2>
    <p> 공부한 자료: 
      <a href="https://learn.microsoft.com/en-us/cpp/windows/walkthrough-creating-windows-desktop-applications-cpp">
        Microsoft Learn -> C++, C, Assembler -> Create a traditional Windows Desktop application
      </a> 
      <p> 
        필요한 프로그램: Visual studio의 도구 설치에서 Desktop development with C++
      </p>
      <p>
        프로젝트 템플릿: Windows 데스크톱 마법사에서 콘솔 애플리케이션
      </p>
      <p>
        헤더 파일: Windows.h
      </p>
      <p>
        Windows.h에는 전처리기 매크로와 타입들이 많이 쓰여서, 윈도우 버전에 상관없이 같은 동작을 보장해준다. 
        그 예로 <code>WINAPI</code>, <code>HINSTANCE</code>, <code>_IN_</code> 등이 있다. 
        IntelliSense의 Quick Info 기능을 쓰면 매크로와 타입의 정의를 볼 수 있다. 
        궁금한 단어를 클릭하고, Ctrl+K, Ctrl+I를 누르면 된다. 
      </p>
      <p>
        창을 만들려면 <code>WinMain</code> 함수를 정의한다. 
        <code>WinMain</code> 함수의 첫번째 인자가 <code>HINSTANCE</code> 타입인데, 
        이 인자는 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winmain">현재 앱을 의미하는 핸들</a>이 된다. 
        <code>WinMain</code>에서 제일 먼저 하는 일은 창 관련 설정인 <code>WNDCLASSEX</code> 
        구조체 변수에 창 정보를 저장하는 것인데, 여기서 <code>.hInstance</code>에 첫번째 인자를 저장한다. 
        그 외에 이벤트 발생시 호출할 함수, 커서 등 다른 정보들도 저장한다. 
        그리고, <code>RegisterClassEx</code>함수의 파라미터로 구조체의 포인터를 전달해서 실행하면
        윈도우 운영체제에 현재 어플리케이션과 창 정보가 등록된다. 
        그리고나서, <code>CreateWindowEx</code>에 현재 앱 핸들, 윈도우 제목 등의 정보를 전달해서 
        실행하면, 창이 만들어지고, 리턴값으로 창 핸들을 받는다. 
        <code>ShowWindow</code> 함수에 창 핸들을 전달해서 실행하면 창이 보인다. 
      </p>
    </p>
    <h2> 후크 개요 </h2>
    <p> 공부한 자료:
      <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-hooks">
        Microsoft Learn -> Windows -> 앱 -> Win32 -> Desktop Technologies -> Desktop App User Interface -> Windows and Messages -> 후크 개요
      </a>
    </p>
    <p> 
      후크란 앱이 마우스, 키보드, 메시지와 같은 이벤트들을 인터셉트하게 해주는 방법이다. 
      후크 함수로 이벤트를 받은 다음에 변형하거나 없앨 수도 있다. 
      후크가 쓰이는 경우는, 디버깅, 매크로, F1 키 헬프 메뉴, 마우스/키보드 입력, 트레이닝 앱이 있다.
      후크는 컴퓨터를 느리게 만들기 때문에 최소한만 쓰고 가능한 빨리 제거해야 한다. 
      후크 체인, 후크 함수, 후크 종류에 대해 이어서 설명한다. 
    </p>
    <h3> 후크 체인 </h3>
    <p>
      메시지 종류별로 후크가 다루는 방식이 다르다. 
      예를 들어 <code>WH_MOUSE</code> 후크는 마우스 메시지를 처리한다. 
      각 후크 타입은 별도의 후크 체인으로 관리되는데, 
      여기서 후크 체인은 후크 함수라고 불리는 앱에서 정의된 함수들에 대한 포인터들의 리스트다. 
      특정 후크 타입의 메시지가 발생하면, 시스템에서는 해당 메시지를 후크 체인에 있는 후크 함수들에
      하나씩 전달한다. 
      어떤 후크 타입의 후크 함수들은 메시지를 읽을 수만 있고, 다른 후크 타입에 대한 후크 함수들은 
      메시지를 변경하거나, 나머지 후크 체인에 전달되지 않게 할 수 있다. 
    </p>
    <h3> 후크 함수 </h3>
    <p> 
      특정 후크 타입을 쓰기 위해, 개발자는 후크 함수를 만들고, <code>SetWindowsHookEx</code> 함수를
      써서 후크 체인에 이를 설치한다. 후크 함수는 다음과 같은 문법을 따라야 한다. 
    </p>
    <code><pre>
      LRESULT CALLBACK HookProc(
        int nCode,
        WPARAM wParam,
        LPARAM lParam
      )
      {
        // 이벤트 처리
        ...

        return CallNextHookEx(NULL, nCode, wParam, lParam);
      }
    </pre></code>
    <p> <code>HookProc</code>은 앱에서 정의된 이름이 들어갈 자리를 표시하고 있다. </p>
    <p> 
      <code>nCode</code>, <code>wParam</code>, <code>lParam</code>은 후크 종류마다 다른데, 
      보통 <code>nCode</code>는 후크 함수가 어떤 상황에 대한 일을 할지 정해주는 코드고, 
      <code>wParam</code>과 <code>lParam</code>은 메시지 관련 정보가 들어간다. 
    </p>
    <p>
      <code>CallNextHookEx</code>를 호출하면 이벤트를 다음 후크 함수에게 넘겨준다.
    </p>

    <p>
      <code>SetWindowsHookEx</code>는 인자로 받은 후크 함수를 항상 후크 체인의 제일 앞에 설치한다.
      어떤 후크 종류는 메시지를 관찰만 할 수 있기 때문에 <code>CallNextHookEx</code>를 호출했는지
      여부와 관계 없이 메시지를 다음 후크 함수에게 전달하지만, 다른 후크 종류에서는 
      <code>CallNextHookEx</code>를 호출하지 않으면 다음 후크 함수가 실행되지 않는다. 
    </p>

    <h3> 후크 타입 </h3>
    <p>
      <code>WH_CBT</code> 후크 함수는 창의 상태나 크기가 바뀌기 전, 시스템 명령어 실행 전, 
      마우스, 키보드 이벤트를 끝내기 전, 입력 포커스를 설정하기 전에 호출된다. 컴퓨터 기반 트레이닝
      앱을 위해 만들어졌다. 
    </p>

    <p>
      <code>WH_KEYBOARD_LL</code> 후크 함수는 키보드 입력 이벤트가 쓰레드에서 처리되기 전에 
      먼저 확인할 수 있게 해준다. 
    </p>

    <p>
      <code>WH_KEYBOARD</code> 후크 함수는 키보드 입력 이벤트를 관찰할 수 있게 해준다.
    </p>

    <p>
      <code>WH_MOUSE_LL</code> 후크 함수는 마우스 입력 이벤트가 처리되기 전에 확인하게 해준다.
    </p>

    <p>
      <code>WH_MOUSE</code> 후크 함수는 마우스 입력 이벤트를 관찰할 수 있게 해준다. 
    </p>
    
    <h2> 후크 쓰기 </h2>
    <p> 공부한 자료:
      <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/using-hooks">
        Microsoft Learn -> Windows -> 앱 -> Win32 -> Desktop Technologies -> Desktop App User Interface -> Windows and Messages
      </a>      
    </p>
    <h3> 후크 설치하고 해제하기 </h3>
    <p>
      <code>SetWindowsHookEx</code> 함수를 호출해서 후크 함수를 설치할 수 있고, 이 때 
      어떤 후크가 후크 함수를 실행할지, 후크 함수가 어떤 쓰레드에 결합될지, 후크 함수의 포인터가
      매개변수로 전달된다.
    </p>
    <p>
      <code>UnhookWindowsHookEx</code> 함수를 호출해서 설치된 후크 함수를 제거할 수 있다. 
    </p>

    <h2> Copilot이 만든 예제 </h2>
    <pre><code>
      #include &lt;windows.h&gt;
      #include &lt;stdio.h&gt;

      LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
        if (nCode == HC_ACTION) {
          KBDLLHOOKSTRUCT* pKeyBoard = (KBDLLHOOKSTRUCT*) lParam;
          if (wParam == WM_KEYDOWN) {
            printf("Key down: %d\n", pKeyBoard->vkCode);
          }
          else if (wParam == WM_KEYUP) {
            printf("Key up: %d\n", pKeyBoard->vkCode);
          }
        }
        return CallNextHookEx(NULL, nCode, wParam, IParam);
      }

      int main() {
        HHOOK hhook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, NULL, 0);
        MSG msg;
        while (GetMessage(&msg, NULL, 0, 0) > 0) {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
        }
        UnhookWindowsHookEx(hhook);
        return 0;
      }
    </code></pre>

    <h3><a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/lowlevelkeyboardproc">LowLevelKeyboardProc 함수</a></h3>
    <p>
      LowLevelKeyboardProc는 SetWindowsHookExW을 호출할때 콜백 함수로 전달된다. 
      인자로는 int nCode, WPARAM wParam, LPARAM lParam을 받는다. 
      nCode가 0보다 작으면, CallNextHookEx를 호출해야한다. 
      nCode의 값은 HC_ACTION(0)만 가질 수 있다. 
      wParam은 키보드 메시지의 종류를 뜻한다. 
      wParam의 값은 WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, 
      WM_SYSKEYUP 중 하나가 된다. 
      lParam은 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-kbdllhookstruct">KBDLLHOOKSTRUCT</a> 구조체의 포인터다. 
      KBDLLHOOKSTRUCT의 구조는 vkCode, scanCode, flags, time, dwExtraInfo다. 
      vkCode는 1부터 254까지 범위의 키보드의 키에 해당하는 숫자다. 
      scanCode는 키에 대한 하드웨어 코드다. 
      flags는 ALT가 눌렸는지, 확장키인지 등의 정보를 준다. 
      time은 메시지의 시간을 보내준다. 
      dwExtraInfo는 추가 메시지를 보내준다. 
    </p>
    <p>
      <code>WH_KEYBOARD_LL</code> 타입의 훅은 이를 설치한 쓰레드의 
      맥락에서 호출된다. 
      호출되는 방식은 이를 설치한 쓰레드에 메시지를 전달하는 것이다. 
      그래서 후크를 설치한 쓰레드에는 메시지 루프가 있어야 한다. 
    </p>
    <p>
      키보드 입력은 로컬 키보드 드라이버에서 올 수 있고,
      <code>keybd_event</code> 함수에서도 호출될 수 있다. 
      보통 주어진 최대 처리 시간은 1초다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-callnexthookex">
        CallNextHookEx
      </a> 함수는 후크 체인에서 다음 함수로 넘어간다. 
    </h3>
    <p>
      인수로는 HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam이 있다. 
      hhk 파라미터는 무시된다. 
      nCode는 후크 정보를 어떻게 해석할지에 대한 코드다. 
      wParam과 lParam에는 현재 후크에 대한 정보가 들어있다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexw">
        SetWindowsHookExW
      </a> 함수는 후크 함수를 설치한다.
    </h3>
    <p>
      인수는 int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId다.
      idHook 파라미터는 어떤 후크인지를 뜻한다. 
      lpfn 파라미터는 후크 함수에 대한 포인터다. 
      hmod 파라미터는 lpfn 후크 함수가 정의된 DLL에 대한 핸들이다. 
      dwThreadId 파라미터는 후크 함수가 연결된 쓰레드를 뜻한다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage">
        GetMessage
      </a> 함수는 메시지 큐에서 메시지를 꺼내온다. 
    </h3>
    <p>
      매개변수는 LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax다. 
      lpMsg는 메시지 정보를 저장할 구조체의 포인터다. 
      hWnd는 메시지를 받으려는 창에 대한 핸들이다. 
      NULL일 때 현재 스레드에 속한 모든 윈도우의 메시지를 받는다. 
      wMsgFilterMin, wMsgFilterMax는 처리할 메시지 번호의 
      최소값, 최대값이다. 모두 0으로 설정하면 모든 메시지를 받는다. 
      리턴값은 메시지가 WM_QUIT일 때 0이고, 그렇지 않으면 0이 아니다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage">
        TranslateMessage
      </a> 함수는 가상 키에서 키보드 문자를 해석한다.  
    </h3>
    <p>
      매개변수는 MSG *lpMsg를 받는다. 
      번역을 했을 때만 0이 아닌 값을 리턴한다.
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessage">
        DispatchMessage
      </a> 함수는 메시지에 해당하는 창의 후크 함수를 실행한다.  
    </h3>
    <p>
      매개변수는 MSG *lpMsg를 받는다. 
      후크 함수에서 리턴한 값을 리턴하며, 보통 쓰이지 않는다. 
    </p>
    <h2>
      <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues?source=recommendations">
        메시지와 메시지 큐
      </a>
    </h2>
    <p>
      MS-DOS 앱에서는 입력을 받기 위해서 함수 호출을 했다. 
      창이 있는 앱들은 이벤트를 쓰기 때문에, 시스템이 입력을 전달해주기를 기다린다. 
      시스템은 앱의 다양한 창에 입력을 전달해준다. 
      각각의 창은 함수를 가지고 있어서, 시스템이 입력을 전달할 때 해당 함수를 호출한다. 
      가장 앞에 있는 창이 몇초 이상 메시지에 반응하지 않으면, 
      시스템은 그 창이 응답하지 않는다고 본다. 
    </p>
    <h3>
      윈도우 메시지
    </h3>
    <p>
      시스템은 윈도우 함수에 입력을 전달할 때 메시지 형태로 한다. 
      메시지는 시스템과 앱에서 만들 수 있다. 
      시스템이 메시지를 만들 때는, 마우스, 키보드 입력이 있을 때, 
      그리고 앱에서 창 크기나 시스템 폰트를 바꿀 때 등이다. 
      앱이 메시지를 만들 때는, 자신의 또는 다른 앱의 창을 조절할 때다. 
    </p>
    <h2>
      <a href="https://learn.microsoft.com/ko-kr/windows/win32/winmsg/using-timers">
        타이머: Microsoft Learn -> 윈도우 -> 앱 -> Win32 -> 데스크톱 기술 -> 데스크톱 앱 사용자 인터페이스 -> 창 및 메시지
      </a>
    </h2>
    <h3> 타이머 만들기 </h3>
    <p>
      타이머를 만들 때는 <code>SetTimer</code> 함수를 쓴다. 
    </p>
    <h3> 
      <a href="https://learn.microsoft.com/ko-kr/windows/win32/api/winuser/nf-winuser-settimer">
        <code>SetTimer</code> 함수
      </a>
    </h3>
    <p>
      매개변수는 HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMEPROC lpTimerFunc다. 
      hWnd는 창에 대한 핸들이며, NULL도 가능하다. 
      nIDEvent는 타이머 ID다. 
      uElapse는 밀리초 단위 제한시간이다. 
      lpTimerFunc은 함수 포인터고, NULL이면 앱 큐에 WM_TIMER가 들어온다. 
      리턴 값은 hWnd가 NULL일 때 새 타이머 ID를 준다. 
    </p>
    <p>
      hWnd 매개 변수가 NULL이고 nIDEvent가 기존 타이머에 없는 경우, 
      전달된 nIDEvent는 무시되고, 새 타이머 ID가 생성되고 반환된다. 
      SetTimer가 타이머를 바꾸면 이전에 설정한 제한 시간 값이 무시된다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/ko-kr/windows/win32/api/winuser/nc-winuser-timerproc?source=recommendations">
        <code>TIMERPROC</code> 콜백 함수
      </a>
    </h3>
    <p>
      매개변수는 HWND unnamedParam1, UINT unnamedParam2, UINT_PTR unnamedParam3, DWORD unnamedParam4다. 
      반환 값은 없다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-killtimer">
        <code>KillTimer</code> 함수
      </a>
    </h3>
    <p>
      지정한 타이머를 제거한다. 
      매개변수는 HWND hWnd, UINT_PTR nIDEvent다. 
      hWnd는 타이머가 설정된 창으로 없으면 NULL을 입력한다. 
      nIDEvent는 타이머 ID와 같아야 한다.
    </p>
    <h2>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-sendinput">
        <Code>SendInput</Code> 함수는 키보드, 마우스 입력을 만든다.
      </a>
    </h2>
    <p>
      매개변수는 UINT cInputs, LPINPUT pInputs, int cbSize다. 
      cInputs는 pInputs에 요소가 몇개 있는지를 뜻한다. 
      pInputs는 INPUT 구조체의 배열이다.
      cbSize는 INPUT 구조체가 몇 바이트인지다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-input">
        <code>INPUT</code>> 구조체
      </a>
    </h3>
    <p>
      요소는 DWORD type, MOUSEINPUT mi다. 
      MOUSEINPUT mi 대신 KEYBDINPUT ki를 쓸 수도 있다. 
      type의 값은 INPUT_MOUSE, INPUT_KEYBOARD, INPUT_HARDWARE가 가능하다.
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-mouseinput">
        MOUSEINPUT 구조체 
      </a>
    </h3>
    <p>
      요소는 dx, dy, mouseData, dwFlags, time, dwExtraInfo가 있다. 
      dx는 x 상대/절대 좌표다. 
      dy는 y 상대/절대 좌표다. 
      mouseData는 dwData가 휠, X 관련이 아닌 이상 0이어야 한다. 
      dwFlags는 MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP 등이 가능하다. 
      time은 이벤트 발생 시간이다. 
    </p>

    <h1> HTML 5일차 </h1>
      <p> 예제 코드: <code>&lt;meta name="description" content="accessed by bot" /&gt;</code></p> 
      <p> 실행 결과: 검색 엔진에서 접근가능하다. </p>
  
      <p>
        <code> name </code> 속성과 <code> contents </code> 속성을 지정하는 방식으로
        어떤 종류의 메타데이터가 무엇이라고 정할 수 있다.
      </p>

    <h2> 파비콘 </h2>
      <p> <code>&lt;link rel="icon" href="favicon.ico" type="image/x-icon" /&gt;</code> </p>
      <p> 제목 왼쪽의 아이콘을 정해준다. </p>

    <h3> 
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link">
        link
      </a> 요소
    </h3>

    <p>
      현재 문서와 외부 자원 간의 관계를 지정해준다. 
    </p>

    <p>
      예제 코드: &lt;link href="main.css" rel="stylesheet" /&gt;
    </p>

    <p>
      실행 결과: main.css 파일이 CSS로 로드된다. 
    </p>

    <h2>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">
        script
      </a> 요소
    </h2>

    <p>
      자바스크립트 코드를 쓴다. 속성으로 src가 있다. 
      src 속성은 외부 자바스크립트 코드를 읽게 해준다. 
    </p>

    <h1> C 5일차 - C2y standard </h1>
    <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
    <h2> Pvii </h2>

    <p> 7. 라이브러리 </p>
    <p> 7.1 서론 </p>
    <p> 7.1.1 용어의 정의 </p>
    <p> 7.1.2 표준 헤더 </p>
    <p> 7.1.3 예약된 식별자 </p>
    <p> 7.1.4 라이브러리 함수의 사용 </p>
    <p> 7.2 진단 &lt;assert.h&gt;</p>
    <p> 7.2.1 일반 </p>
    <p> 7.2.2 프로그램 진단 </p>
    <p> 7.3 복소수 연산 &lt;complex.h&gt;</p>
    <p> 7.3.1 서론 </p>
    <p> 7.3.2 규칙 </p>
    <p> 7.3.3 각의 범위 제한하기 </p>
    <p> 7.3.4 CX_LIMITED_RANGE 컴파일러 지시자 </p>
    <p> 7.3.5 삼각 함수 </p>
    <p> 7.3.6 쌍곡선 함수 </p>
    <p> 7.3.7 지수 및 로그 함수 </p>
    <p> 7.3.8 멱함수 및 절대값 함수 </p>
    <p> 7.3.9 조작 함수 </p>
    <p> 7.4 문자 처리 함수 &lt;ctype.h&gt; </p>
    <p> 7.4.1 일반 </p>
    <p> 7.4.2 문자 분류 함수 </p>
    <p> 7.4.3 문자 대소문자 변환 함수 </p>
    <p> 7.5 에러 &lt;errno.h&gt; </p>
    <p> 7.6 부동소수점 환경 &lt;fenv.h&gt;</p>
    <p> 7.6.1 일반 </p>
    <p> 7.6.2 FENV_ACCESS 컴파일러 지시자 </p>
    <p> 7.6.3 FENV_ROUND 컴파일러 지시자 </p>
    <p> 7.6.4 FENV_DEC_ROUND 컴파일러 지시자 </p>
    <p> 7.6.5 부동소수점 예외 </p>
    <p> 7.6.6 반올림 및 기타 조절 모드 </p>
    <p> 7.6.7 환경 </p>
    <p> 7.7 부동소수점 타입의 특징 &lt;float.h&gt;</p>
    <p> 7.8 정수 타임의 포맷 변경 &lt;inttypes.h&gt;</p>
    <p> 7.8.1 일반 </p>
    <p> 7.8.2 포맷 지정자 매크로 </p>
    <p> 7.8.3 가장 큰 정수 타입을 위한 함수 </p>
    <p> 7.9 다른 철자법 &lt;iso646.h&gt;</p>
    <p> 7.10 정수 타입의 특성 &lt;limits.h&gt;</p>
    <p> 7.11 지역화 &lt;locale.h&gt;</p>

    <h1> HTML 6일차 </h1>
    <h3> 문서의 언어 설정하기 </h3>
    <p>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang">
        lang 전역 속성
      </a>
    </p>
    <p> 화면 읽는 기계 등에서 알 수 있게 언어를 정해준다. </p>

    <h2> 
      <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Headings_and_paragraphs">
        HTML에서 제목과 문단
      </a>
    </h2>

    <h3>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p">
        p 요소
      </a>는 각 문단을 표시한다.
    </h3>

    <p> 예제 코드: 
      &lt;p&gt; ...문단 내용... &lt;/p&gt; 
    </p>

    <p> 실행 결과: <p> ...문단 내용... </p> </p>

    <h3>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements">
        h1, h2, ... , h6 요소
      </a>는 제목을 표시한다. 
    </h3>

    <p> 예제 코드:
      &lt;h1&gt; _제목_ &lt;/h1&gt; 
    </p>

    <p> 실행 결과: <h1> _제목_ </h1> </p>

    <h1> C 6일차 - C2y standard </h1>
    <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
    <h2> Pviii </h2>

    <p> 7.11.1 일반</p>
    <p> 7.11.2 setlocale 함수 </p>
    <p> 7.11.3 숫자 포맷팅 방법 설문조사 </p>
    <p> 7.12 수학 &lt;math.h&gt; </p>
    <p> 7.12.1 일반 </p>
    <p> 7.12.2 에러 조건 처리 </p>
    <p> 7.12.3 FP_CONTRACT 컴파일러 지시자 </p>

    <h1> ML 1일차 - MNIST 숫자 손글씨 이미지 </h1>
    <p> 공부한 자료: 
      <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/MNIST-SPM2012.pdf">
        The MNIST Database of Handwritten Digit Images for Machine Learning Research
      </a>, Li Deng, <i>IEEE Signal Processing Magazine best of THE WEB</i>, 2012
    </p>

    <p> 
      MNIST: modified National Institute of Standards and Technology 
      (미국국립표준기술연구소의 변형). 손으로 쓴 숫자 이미지로 
      문자 인식과 기계 학습 연구에서 많이 쓰이고 있음. 무료임.
    </p>

    <p> 
      데이터 주소: <a href=" http: //yann.lecun.com/exdb/mnist">
        http: //yann.lecun.com/exdb/mnist
      </a>. 접속에 어려움 있음.
    </p>

    <p>
      MNIST 데이터베이스는 NIST 데이터베이스로부터 제작됨.
      학습할 이미지 60,000개, 테스트할 이미지 10,000개 있음. 
      모두 흑백이고, 가로 세로 28개 픽셀, 가운데 정렬 됨. 
    </p>

    <p>
      기계 학습 알고리즘들에 대한 평가도 같은 홈페이지에서 보여줌. 
      기계 학습 테크닉은 크게 다음과 같이 분류됨:  
      선형 분류, k개 가장 가까운 지역, 여러 모델 결합, 
      비선형 분류, 최적화, 신경망, 필터된 신경망.
    </p>

    <p>
      다른 방법들 중 신경망 분류기가 주로 성능이 높은 편임. 
      필터된 신경망이 성능이 가장 높음. 
      딥러닝으로 10,000개 테스트 이미지 중 35개 에러 달성. 
      데이터에 변형을 주는 것이 에러율을 낮추는데 중요함. 
      변형 없이는 53개로 에러 증가. 
      신경망의 깊이가 얕으면 에러가 110개로 증가. 
    </p>

    <p>
      신경망 분류기 다음으로는 k개 가장 가까운 지역 방법과 
      가상 최적화 방법이 정확하게 분류
    </p>
  </body>
</html>
