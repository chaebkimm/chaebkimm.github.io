<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>나의 배움 일기</title>
</head>
<body>
  <h1> HTML 1일차 </h1>
  <p> 공부한 자료: <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Basic_HTML_syntax">Mozilla Developer Network 학습자료의 기초 HTML 문법</a> </p>
  <h2> HTML이란 </h2>
  <p> 
    웹페이지의 내용을 적는 문법으로 구성요소(Element)들로 이뤄져있다. 
    구성요소를 적는 문법은 <code> &lt;이름&gt; 내용 &lt;/이름&gt; </code>이다. 
    &lt;&gt; 안에 들어가는 구성요소 이름을 태그라고 부른다. 
  </p>
  <h3> HTML의 구성요소들 </h3>
  <p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p"><code> &lt;p&gt; 내용 &lt;/p&gt;</code></a>
    내용을 한문단(paragraph)으로 묶는다.
  </p>
  <p>
    예제 코드: &lt;p&gt; 첫번째 문단 &lt;/p&gt; &lt;p&gt; 두번째 문단 &lt;/p&gt;
  </p>
  <p> 실행 결과: </p>
  <p> 첫번째 문단 </p>
  <p> 두번째 문단 </p>

  <h1> C 1일차 </h1>
  <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
  <h2> Pi </h2>
  <p> 정보 기술 - 프로그래밍 언어 - C </p>
  <p> 답장을 보낼 메일 주소: JeanHeyd Meneide &lt;wg14@soasis.org&gt; </p>
  <p> Freek Wiedijk &lt;freek@cs.ru.nl&gt; </p>
  <p> 초록 (ISO에 의해 바뀔 예정) </p>
  <p> 본 문서는 프로그래밍 언어 C로 작성된 프로그램의 형식과 번역방식을 정한다. 본 문서의 목적은 다양한 컴퓨터 시스템에서 C 언어 프로그램의 효율적 실행, 유지보수, 안정성, 이식성을 장려하는 것이다. </p>
  <p> C 언어 자체에 대한 세부 내용과, C 언어 실행 라이브러리의 내용이 들어있다. 붙임 문서에서 두 경우를 모두 다루며, C 프로그램의 이식성에 영향을 주는 요소들을 나열한다. </p>
  <p> 본 문서는 C 언어 프로그래머와 C 언어 번역 시스템 개발자들에게 가이드를 제시하려고 하지만, 본 문서 자체가 튜토리얼 기능을 하기 위해 설계되지는 않았다. </p>
  <p> 본 초안을 받은 사람들은 본인이 알고 있는 관련된 특허권에 대해 코멘트와 증빙 서류를 제출할 수 있다. </p>
  <p> C23 사이클이 끝난 뒤에 본 문서의 다음 버전인 "C2y" 작업이 2024년 1월 24일에 시작되었다. </p>
  <p> 2024년 1월 </p>
  <p> 2024년 프랑스 스트라스부르 미팅에서 다음 변경 사항이 반영되었다. </p>
  <p> - N3192: 순서가 있는 16진수 </p>
  <p> - 편집자: 붙임 K의 한 주석에서 "예약됨"을 "예약될 수 있음"으로 변경 </p>
  <p> 2024년 6월 </p>
  <p> 2024 6월 가상 미팅에서 다음과 같은 내용이 변경되었다. </p>
  <p> - N3064: 바이트 여러개로 구성된 문자들로 이뤄진 파일에 쓰기 </p>
  <p> - N3232: 반올림 한 값에서 원래 값 얻기 </p>
  <p> - N3233: printf 반올림 권장 방법 </p>
  <p> - N3239: 값 자체인 상수 버전 2 </p>
  <p> - N3242: "정확한 반올림"을 쓸 때 문제점 </p>
  <p> - N3244: 세속적인 악마들을 물리치기 (6.3.2.1, 6.7.2, 6.7, 6.7.5, 6.7.6 변경) </p>
  <p> - N3247: fopen "p"와 fopen의 모드를 POSIX 202x에 비슷하게 맞추기 </p>
  <p> - N3254: 바이트 배열에 접근하기, 버전 4 </p>
  <p> - N3259: 복소수에서의 ++, -- 지원 </p>
  <p> - N3260: _Generic에서 타입 피연산자를 선택하기 </p>


  <h1> HTML 2일차 </h1>
  <p> 공부한 자료: <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Basic_HTML_syntax">Mozilla Developer Network 학습자료의 기초 HTML 문법</a> </p>
  <h2> 요소 안의 요소 </h2>
  <p> 
    구성요소 안에 구성요소를 적는 문법은 <code> &lt;바깥요소이름&gt; 바깥요소내용1 &lt;안요소이름&gt; 안요소내용 &lt;/안요소이름&gt; 바깥요소내용2 &lt;/바깥요소이름&gt; </code>이다. 
    요소 안에 요소를 계속 추가할 수 있다.
  </p>
  <h2> 속성 </h2>
    <p> 
      속성은 요소에 대한 정보를 주는 것인데, 요소의 내용이 아니어서 보이지는 않는다.  
      <code> &lt;요소이름 속성이름="속성값"&gt; </code> 형식으로 쓴다.  
      속성 문법의 규칙으로, 먼저 속성이름과 요소이름 사이에 띄어쓰기가 있어야 한다. 
      속성 여러개를 쓸 때도 속성들 사이에 띄어쓰기가 있어야 한다.
      속성 이름 다음에 등호 <code> = </code>가 있어야 한다.
      등호 다음에 속성 값이 따옴표 <code> ' ' </code> 또는 <code> " " </code> 안에 있어야 한다. 
    </p>
  <h2> 비어있는 요소 </h2>
    <p> 
      어떤 요소는 안에 들어가는 내용이 없다. 그래서 다음과 같이 태그에 속성만 적고, 닫는 태그와 내용은 쓰지 않아도 된다.
      <code> &lt;요소이름 속성 /&gt; </code>
      HTML에서는 <code>/</code>가 없어도 되지만, XML 문법과의 호환성을 위해 쓰는 것이 좋다. 
    </p>
  <h3> 비어있는 요소와 속성의 예시 </h3>
  <p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img"><code> &lt;img src="그림파일경로" 기타속성="기타속성값" /&gt; </code></a>
    웹페이지에 이미지를 넣는다. 
    src 속성은 반드시 필요하며, 이미지 파일의 경로를 정한다. 
  </p>
  <p>
    예제 코드: &lt;img src="/program.png" /&gt;
  </p>
  <p> 실행 결과: <img src="/program.png" /> </p>
  <p> <code> width </code> 속성은 이미지의 너비를 픽셀 단위로 정한다. </p>
  <p>
    예제 코드: &lt;img src="/program.png" width="300" /&gt;
  </p>
  <p> 실행 결과: <img src="/program.png" width="300" /> </p>
  <p> <code> height </code> 속성은 이미지의 높이를 픽셀 단위로 정한다. </p>
  <p>
    예제 코드: &lt;img src="/program.png" width="300" height="150" /&gt;
  </p>
  <p> 실행 결과: <img src="/program.png" width="300" height="150" /> </p>

  <h1> C 2일차 - C2y standard </h1>
  <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
  <h2> Pii </h2>
  <p> - N3273: 불완전 배열 타입의 alignof </p>
  <p> - N3274: 허수 타입 제거하기 버전 3 </p>
  <p> - 편집자: ISO / IEC 지침에 따라 해야한다(may)를 할수있다(can)으로 변경 </p>
  <p> - 편집자: ISO / IEC 지침에 따라 표 소제목 변경 </p>

  <p> 2024년 9월/10월 </p>
  <p> 2024년 9월/10월 미국 미니애폴리스 미팅 후 다음 변경 사항이 반영되었다. </p>
  <p> - N3272: strftime을 할 때 구조체 내용의 해석 방법 (옵션 1: 정해지지 않음) </p>
  <p> - N3286: 매크로 바꾸기를 할 때 부동소수점 예외 </p>
  <p> - N3287: 수학 관련 규격 문서에서 괄호 위치 오타 </p>
  <p> - N3291: 십진수 부동 소수점 숫자 단어의 잘못된 사용 </p>
  <p> - N3298: 복소수 리터럴 도입 (4.2에서 제안된 내용 배제) </p>
  <p> - N3303: HUGE_VAL 수정 </p>
  <P> - N3305: &lt;math.h&gt;에서 십진 부동소숫점과 관련된 WANT 매크로 삭제 </P>
  <p> - N3312: Atomic의 Alignment 조건을 완화하기 </p>
  <p> - N3322: null에 연산 허용하기, 라이브러리 함수의 인자로 허용하기 </p>
  <p> - N3323: 어떤 것에 1을 더할 때 적절한 타입 쓰기 </p>
  <p> - N3324: "극점-오류" 단어로 고치기 </p>
  <p> - N3326: strnlen 함수와 wcsnlen 함수 추가 </p>
  <p> - N3340: 세속적인 악마들을 물리치기 II </p>
  <p> - N3341: 세속적인 악마들을 물리치기 III </p>
  <p> - N3342: 세속적인 악마들을 물리치기 IV </p>
  <p> - N3344: 세속적인 악마들을 물리치기 VI </p>
  <p> - N3345: 세속적인 악마들을 물리치기 VII </p>
  <p> - N3346: 세속적인 악마들을 물리치기 VIII </p>
  <p> - N3347: 세속적인 악마들을 물리치기 IX </p>
  <p> - N3353: 8진수 리터럴 표기법 변경 </p>
  <p> - N3355: 루프에 라벨링하기 </p>
  <p> - N3356: if에서 선언하기 </p>
  <p> - N3364: SNAN으로 초기화 </p>
  <p> - N3366: 효율적인 문자 인코딩 변환을 위한 재시작 가능 함수 </p>
  <p> - N3367: 더 현대적인 비트 기능들 </p>
  <p> - N3369: _Lengthof 연산자 </p>
  <p> - N3370: switch문에서의 case 범위 </p>

  <h1> C 2일차 - GNU C 언어 매뉴얼 </h1>
  <p> 공부한 자료: <a href="https://www.gnu.org/software/c-intro-and-ref/manual/html_node/index.html">International Standard Organization의 C23 standard</a> </p>
  <h2> 짧은 목차 </h2>
  <p> 1 첫번째 예제 </p>
  <p> 2 완성된 프로그램 </p>
  <p> 3 저장소와 데이터 </p>
  <p> 4 정수를 넘어서 </p>
  <p> 5 단어 규칙 </p>
  <p> 6 산수 </p>
  <p> 7 대입식 </p>
  <p> 8 실행 제어 식 </p>
  <p> 9 이항 연산자 문법 </p>
  <p> 10 실행 순서 </p>
  <p> 11 원시 자료형 </p>
  <p> 12 상수 </p>
  <p> 13 자료형 크기 </p>
  <p> 14 포인터 </p>
  <p> 15 구조체 </p>
  <p> 16 배열 </p>
  <p> 17 열거형 </p>
  <p> 18 자료형 이름 정의 </p>
  <p> 19 문장 </p>
  <p> 20 변수 </p>
  <p> 21 자료형 한정자 </p>
  <p> 22 함수 </p>
  <p> 23 호환되는 자료형 </p>
  <p> 24 형변환 </p>
  <p> 25 유효범위 </p>
  <p> 26 전처리 </p>
  <p> 27 고급 정수 </p>
  <p> 28 고급 부동소수점 </p>
  <p> 29 컴파일 </p>
  <p> 30 컴파일 지시하기 </p>
  <p> 붙임 A 자료형 정렬 </p>
  <p> 붙임 B 메모리 값을 다른 자료형으로 쓰기 </p>
  <p> 붙임 C 별칭 </p>
  <p> 붙임 D 선언에서의 속성 </p>
  <p> 붙임 E 신호 </p>
  <p> 붙임 F GNU 자유 문서 라이선스 </p>
  <p> 붙임 G GNU 일반 공공 라이선스 </p>
  <p> 기호와 키워드 목차 </p>
  <p> 개념 목차 </p>

  <h2> 목차 </h2>
  <p> 1 첫번째 예제 </p>
  <p> 1.1 예제: 재귀적인 피보나치 </p>
  <p> 1.1.1 함수 헤더 </p>
  <p> 1.1.2 함수 바디 </p>
  <p> 1.2 스택, 스택 오버플로우 </p>
  <p> 1.3 예제: 반복적인 피보나치</p>
  <p> 2 완성된 프로그램 </p>
  <p> 2.1 완성된 프로그램 예제 </p>
  <p> 2.2 완성된 프로그램 설명 </p>
  <p> 2.3 완성된 프로그램, 한줄씩 </p>
  <p> 2.4 완성된 프로그램 컴파일하기 </p>
  <p> 3 저장소와 데이터 </p>
  <p> 4 정수를 넘어서 </p>
  <p> 4.1 정수가 아닌 숫자를 쓰는 예제 </p>
  <p> 4.2 배열을 쓰는 예제 </p>
  <p> 4.3 함수 호출에서 배열을 쓰는 예제 </p>
  <p> 4.4 배열을 쓰는 여러 방법 예제 </p>
  <p> 5 단어 규칙 </p>
  <p> 5.1 프로그램을 영어로 쓰기! </p>
  <p> 5.2 문자들 </p>
  <p> 5.3 공백 </p>
  <p> 5.4 주석 </p>
  <p> 5.5 식별자 </p>
  <p> 5.6 연산자와 구두점 </p>
  <p> 5.7 줄 이어쓰기 </p>
  <p> 6 산수 </p>
  <p> 6.1 기초 산수 </p>
  <p> 6.2 정수 산수 </p>
  <p> 6.3 정수 오버플로우 </p>
  <p> 6.3.1 부호 없는 정수의 오버플로우 </p>
  <p> 6.3.2 부호 있는 정수의 오버플로우 </p>
  <p> 6.4 여러 자료형간 산수 </p>
  <p> 6.5 나누기와 나머지 </p>
  <p> 6.6 숫자 비교 </p>
  <p> 6.7 비트 이동 연산자 </p>
  <p> 6.7.1 비트 이동으로 새로운 비트들이 만들어짐 </p>
  <p> 6.7.2 비트 이동에서 지켜야 할 원칙 </p>
  <p> 6.7.3 비트 이동 꿀팁 </p>
  <p> 6.8 비트별 연산 </p>
  <p> 7 대입식 </p>
  <p> 7.1 단순 대입 </p>
  <p> 7.2 왼쪽값 </p>
  <p> 7.3 값을 변경하는 대입 </p>
  <p> 7.4 증가연산자와 감소연산자 </p>
  <p> 7.5 후에 증가시키고 감소시키기 </p>
  <p> 7.6 위험: 식 내부에서 대입할 때 </p>
  <p> 7.7 별개의 문장에서 대입하기 </p>
  <p> 8 실행 제어 식 </p>
  <p> 8.1 논리 연산자 </p>
  <p> 8.2 논리 연산자와 비교 </p>
  <p> 8.3 논리 연산자와 대입 </p>
  <p> 8.4 조건 식 </p>
  <p> 8.4.1 조건 연산자의 규칙 </p>
  <p> 8.4.2 조건 연산자의 갈래들 </p>
  <p> 8.5 쉼표 연산자 </p>
  <p> 8.5.1 쉼표 연산자의 사용 </p>
  <p> 8.5.2 쉼표 연산자의 깔끔한 사용 </p>
  <p> 8.5.3 쉼표 연산자를 쓰지 말아야 할 때 </p>
  <p> 9 이항 연산자 문법 </p>
  <p> 10 실행 순서 </p>
  <p> 10.1 피연산자 순서 바꾸기 </p>
  <p> 10.2 결합 법칙과 순서 </p>
  <p> 10.3 모든 연산이 완료되는 시점 </p>
  <p> 10.4 후에 증가시키는 연산과 순서 </p>
  <p> 10.5 피연산자의 순서 </p>
  <p> 10.6 최적화와 순서 </p>
  <p> 11 원시 자료형 </p>
  <p> 11.1 정수 자료형 </p>
  <p> 11.1.1 기본 정수 </p>
  <p> 11.1.2 부호가 있는 자료형과 부호가 없는 자료형 </p>
  <p> 11.1.3 크기가 작은 정수 </p>
  <p> 11.1.4 정수 자료형 간의 변환 </p>
  <p> 11.1.5 논리 자료형 </p>
  <p> 11.1.6 정수 자료형의 다양성 </p>
  <p> 11.2 부동소수점 자료형 </p>
  <p> 11.3 복소수 자료형 </p>
  <p> 11.4 void형 </p>
  <p> 11.5 기타 자료형 </p>
  <p> 11.6 타입이 정해지는 규칙 </p>

  
  <h1> HTML 3일차 </h1>
  <p> 공부한 자료: <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Basic_HTML_syntax">Mozilla Developer Network 학습자료의 기초 HTML 문법</a> </p>
  <h3> 논리 속성 </h3>
    <p> 논리 속성은 참이나 거짓으로 설정되는 속성이다. 논리 속성을 값 없이 쓰거나, 
      어떤 값이든 넣어서 쓰면 참으로 설정된다. 매뉴얼에서는 값을 비어있는 문자열이나, 
      논리 속성 이름으로 설정하라고 하지만, 다른 값을 넣어도 똑같이 작동한다. 
      반대로 논리 속성을 요소 안에 쓰지 않으면, 해당 논리 속성은 거짓으로 설정된다. 
    </p>
  <h3> 논리 속성이 있는 요소 예시 </h3>
  <p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">
      <code> &lt;input type="입력방법" /&gt; </code>
    </a>
    웹페이지에 입력을 받을 수 있는 요소를 만든다.
  </p>
  <p>
    예제 코드: <code> &lt;input type="text" /&gt; </code>
  </p>
  <p> 실행 결과: <input type="text" /> </p>
  <p> <code> disabled </code> 논리 속성은 값을 변경할 수 없게 한다. </p>
  <p>
    예제 코드: <code> &lt;input type="text" disabled /&gt; </code>
  </p>
  <p> 실행 결과: <input type="text" disabled /> </p>
  <h2> HTML 문서의 구성 </h2>
  <p> HTML 문서는 다음과 같이 구성되어 있다. </p>
  <code><pre>
    &lt;!doctype html&gt;
    &lt;html lang="ko-KR"&gt;
      &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;제목&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;p&gt;내용&lt;/p&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  </pre></code>
  여기서, 

  <ol>
    <li>
      <code>&lt;!doctype html&gt;</code>은 90년대 html 규격 링크를 다는데 쓰였다. 지금은 html 문서임을 정한다.
    </li>
    <li>
      <code>&lt;html&gt;&lt;/html&gt;</code>은 전체 HTML 페이지에 해당하는 요소다. 
    </li>
    <li>
      <code>&lt;head&gt;&lt;/head&gt;</code>는 보여지지 않는 모든 내용을 담는 요소다. 스타일, 쓸 문자들 등이 있다.
    </li>
    <li>
      <code>&lt;meta charset="utf-8" /&gt;</code>는 UTF-8로 인코딩된 문자들을 쓰겠다는 것을 의미한다.
    </li>
    <li>
      <code>&lt;title&gt;&lt;/title&gt;</code>은 페이지의 제목을 설정한다. 
    </li>
    <li>
      <code>&lt;body&gt;&lt;/body&gt;</code>는 페이지에 보이는 모든 것을 담는 요소다. 
    </li>
  </ol>

  <h2> HTML에서 공백문자 </h2>
  <p> 공백 문자를 많이 쓰더라도 띄어쓰기 한칸으로 인식된다. 다음 두 코드는 같은 결과를 보여준다. </p>
  <code><pre>
    &lt;p id="공백없음"&gt; 띄어 쓰기 &lt;/p&gt;

    &lt;p id="공백많음"&gt; 띄어 
          쓰기 &lt;/p&gt;
  </pre></code>

  <h2> HTML에서 특수문자 쓰기 </h2>
  <p> 
    HTML에서 <code><</code>, <code>></code>, <code>"</code>, <code>'</code>, <code>&</code>는 특수문자이다. 
    <code><</code>는 <code>&amp;lt;</code>로, <code>></code>는 <code>&amp;gt;</code>로, 
    <code>"</code>는 <code>&amp;quot;</code>로, <code>'</code>는 <code>&amp;apos;</code>로,
    <code>&</code>는 <code>&amp;amp;</code>로 쓸 수 있다.
  </p>
  <p> 예제 코드: <code>&amp;lt; &amp;amp;lt;</code> </p>
  <p> 실행 결과: <code>&lt; &amp;lt;</code> </p>


  <h2> HTML 주석 </h2>
  <p>
    HTML에서 주석을 쓰려면 <code>&lt;!--</code>와 <code>--&gt;</code> 사이에 쓴다. 
  </p>
  <p> 예제 코드: <code>&lt;p&gt;주석 밖&lt;/p&gt; &lt;!-- &lt;p&gt;주석 안&lt;/p&gt; --&gt;</code> </p>
  <p> 실행 결과: </p>
  <p>주석 밖</p> <!--주석 안-->


  <h1> C 3일차 - C2y standard </h1>
  <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
  <h2> Piii </h2>
  <p> </p>
  <h2> Piv </h2>
  <p> 목차 </p>
  <p> 서문 ... xiv </p>
  <p> 서론 ... xv </p>
  <p> 1 다루는 범위 ... 1 </p>
  <p> 2 참고한 표준 ... 2 </p>
  <p> 3 단어, 정의, 기호 ... 3 </p>
  <p> 4 적합성 ... 9 </p>
  <p> 5 환경 ... 11 </p>
  <p> 5.1 서론 ... 11 </p>
  <p> 5.2 개념적 모델 ... 11 </p>
  <p> 5.2.1 번역 환경 ... 11 </p>
  <p> 5.2.2 실행 환경 ... 12 </p>
  <p> 5.3 환경에서 고려할 점 ... 19 </p>
  <p> 5.3.1 문자셋 ... 19 </p>
  <p> 5.3.2 2바이트 이상의 문자들 ... 20 </p>
  <p> 5.3.3 화면에 문자를 표시할 때 ... 21 </p>
  <p> 5.3.4 신호와 인터럽트 ... 21 </p>
  <p> 5.3.5 환경 관련 제약 ... 21 </p>
  <p> 6. 언어 ... 36 </p>
  <p> 6.1 표기법 ... 36 </p>
  <p> 6.2 개념 ... 36 </p>
  <p> 6.2.1 식별자의 범위, 타입 이름, 복합 리터럴 ... 36 </p>
  <p> 6.2.2 식별자간 링크 ... 37 </p>
  <p> 6.2.3 식별자의 이름 공간 ... 38 </p>
  <p> 6.2.4 객체의 저장 기간 ... 38 </p>
  <p> 6.2.5 자료형 ... 39 </p>
  <p> 6.2.6 자료형이 저장되는 방법 ... 43 </p>
  <p> 6.2.7 호환가능한 자료형과 합성 자료형 ... 44 </p>
  <p> 6.2.8 객체의 정렬 ... 46 </p>
  <p> 6.2.9 인코딩 ... 46 </p>
  <p> 6.3 자료형 변환 ... 47 </p>
  <p> 6.3.1 서론 ... 47 </p>
  <p> 6.3.2 산술 피연산자 ... 47 </p>
  <h2> Pv </h2>
  <p> 6.3.3 기타 피연산자 ... 51 </p>
  <p> 6.4. 단어 구성요소 ... 54 </p>
  <p> 6.4.1 일반 ... 54 </p>
  <p> 6.4.2 키워드 ... 55 </p>
  <p> 6.4.3 식별자 ... 56 </p>
  <p> 6.4.4 국제 문자 ... 58 </p>
  <p> 6.4.5 상수 ... 60 </p>
  <p> 6.4.6 문자열 리터럴 ... 71 </p>
  <p> 6.4.7 구두점 ... 72 </p>
  <p> 6.4.8 헤더 이름 ... 73 </p>
  <p> 6.4.9 전처리 숫자 ... 74 </p>
  <p> 6.4.10 주석 ... 74 </p>
  <p> 6.5 수식 ... 76 </p>
  <p> 6.5.1 일반 ... 76 </p>
  <p> 6.5.2 가장 간단한 식 ... 77 </p>
  <p> 6.5.3 피연산자 뒤에 있는 연산자 ... 79 </p>
  <p> 6.5.4 단항 연산자 ... 86 </p>
  <p> 6.5.5 형변환 연산자 ... 89 </p>
  <p> 6.5.6 곱셈 연산자 ... 89 </p>
  <p> 6.5.7 덧셈 연산자 ... 90 </p>
  <p> 6.5.8 비트 이동 연산자 ... 91 </p>
  <p> 6.5.9 관계 연산자 ... 92 </p>
  <p> 6.5.10 등호 연산자 ... 93 </p>
  <p> 6.5.11 비트별 AND 연산자 ... 94 </p>
  <p> 6.5.12 비트별 XOR 연산자 ... 94 </p>
  <p> 6.5.13 비트별 OR 연산자 ... 94 </p>
  <p> 6.5.14 논리 AND 연산자 ... 94 </p>
  <p> 6.5.15 논리 OR 연산자 ... 95 </p>
  <p> 6.5.16 조건 연산자 ... 95 </p>
  <p> 6.5.17 대입 연산자 ... 96 </p>
  <p> 6.5.18 쉼표 연산자 ... 99 </p>
  <p> 6.6 상수 식 ... 100 </p>
  <p> 6.6.1 상수 범위 식 ... 101 </p>
  <p> 6.7 선언 ... 104 </p>
  <p> 6.7.1 일반 ... 104</p>
  <p> 6.7.2 저장유형 지정자 ... 106 </p>
  <p> 6.7.3 자료형 지정자 ... 110 </p>
  <p> 6.7.4 자료형 한정자 ... 127 </p>
  <p> 6.7.5 함수 한정자 ... 131 </p>
  <p> 6.7.6 정렬 지정자 ... 132 </p>
  <h2> Pvi </h2>
  <p> 6.7.7 선언자 ... 133 </p>
  <p> 6.7.8 자료형 이름 ... 139 </p>
  <p> 6.7.9 자료형 정의 ... 140 </p>
  <p> 6.7.10 자료형 추론 ... 142 </p>
  <p> 6.7.11 초기화 ... 143 </p>
  <p> 6.7.12 정적 확인 ... 149 </p>
  <p> 6.7.13 속성 ... 149 </p>
  <p> 6.8 문장과 블록 ... 160 </p>
  <p> 6.8.1 일반 ... 160 </p>
  <p> 6.8.2 이름붙은 문장 ... 161 </p>
  <p> 6.8.3 합성 문장 ... 161 </p>
  <p> 6.8.4 수식 문장과 null 문장 ... 162 </p>
  <p> 6.8.5 선택 문장 ... 162 </p>
  <p> 6.8.6 반복 문장 ... 165 </p>
  <p> 6.8.7 점프 문장 ... 166 </p>
  <p> 6.9 외부 정의 ... 171 </p>
  <p> 6.9.1 일반 ... 171 </p>
  <p> 6.9.2 함수 정의 ... 171 </p>
  <p> 6.9.3 외부 객체 정의 ... 173 </p>
  <p> 6.10 전처리 지시 ... 175 </p>
  <p> 6.10.1 일반 ... 175 </p>
  <p> 6.10.2 조건부 포함 ... 178 </p>
  <p> 6.10.3 소스 파일 포함 ... 192 </p>
  <p> 6.10.4 이진 파일 포함 ... 183 </p>
  <p> 6.10.5 매크로로 바꾸기 ... 190 </p>
  <p> 6.10.6 줄 제어 ... 197 </p>
  <p> 6.10.7 진단용 지시 ... 198</p>
  <p> 6.10.8 컴파일러 대상 지시 ... 198 </p>
  <p> 6.10.9 null 지시 ... 199 </p>
  <p> 6.10.10 미리 정해진 매크로 이름 ... 199 </p>
  <p> 6.10.11 컴파일러 대상 지시 연산자 ... 201 </p>
  <p> 6.11 미래 발전 방향 ... 203 </p>
  <p> 6.11.1 부동소수점 자료형 ... 203 </p>
  <p> 6.11.2 식별자 링크 ...  203 </p>
  <p> 6.11.3 외부 이름 ... 203 </p>
  <p> 6.11.4 표현하기 어려운 문자 ... 203 </p>
  <p> 6.11.5 저장유형지정자 ... 203 </p>
  <p> 6.11.6 8진수 표기법 ... 203 </p>
  <p> 6.11.7 컴파일러 지시 ... 203 </p>
  <p> 6.11.8 미리 정해진 매크로 이름 ... 203 </p>

  <h1> HTML 4일차 </h1>
  <p> 공부한 자료: 
    <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Webpage_metadata">
      MDN docs -> core learning modules -> HTML -> head
    </a> 
  </p>
  <h2> head와 메타 데이터 </h2>
    <p> 
      head에는 화면에는 보이지 않는 메타데이터가 저장된다. 
      페이지 제목, 그래픽 관련 설정, 탭에 표시되는 아이콘, 키워드 등이 여기에 해당한다. 
    </p>
    <p> 예제 코드: </p>
    <code><pre>
      &lt;!doctype html&gt;
      &lt;html lang="ko-KR"&gt;
        &lt;head&gt;
          &lt;meta charset="utf-8" /&gt;
          &lt;title&gt;제목&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;내용&lt;/p&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre></code>
    <p> 
      여기서, <code>&lt;head&gt;</code> 요소 안에 있는 것들이 HTML head가 된다. 
      head 안에 있는 <code>&lt;title&gt;</code> 요소는 탭에서의 제목, 즐겨찾기의 제목이 된다. 
    </p>

    <h3> 
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta">
        <code> &lt;meta 속성이름="속성값" /&gt;</code>
      </a>
      : 메타 데이터를 공식적으로 HTML 문서에 추가하는 요소
    </h3>

    <p>
      <code> charset </code> 속성은 문서에서 쓸 문자들을 정해준다. 
      <code> utf-8 </code>은 세계 대부분 나라의 문자를 표현할 수 있고, 한글도 표현가능하다. 
      <code> ISO-8859-1 </code>은 영어와 라틴 문자들만 표현할 수 있고, 한글은 깨진다. 
    </p>

    <p> 예제 코드: <code>&lt;meta charset="utf-8" /&gt;</code></p> 
    <p> 실행 결과: <code>utf-8</code>의 문자들 사용 가능 </p>

    <p>
      <code> name </code> 속성과 <code> contents </code> 속성을 지정하는 방식으로
      어떤 종류의 메타데이터가 무엇이라고 정할 수 있다.
    </p>


    <h1> Windows API 1일차 </h1>
    <h2> 윈도우 창 만들기 </h2>
    <p> 공부한 자료: 
      <a href="https://learn.microsoft.com/en-us/cpp/windows/walkthrough-creating-windows-desktop-applications-cpp">
        Microsoft Learn -> C++, C, Assembler -> Create a traditional Windows Desktop application
      </a> 
      <p> 
        필요한 프로그램: Visual studio의 도구 설치에서 Desktop development with C++
      </p>
      <p>
        프로젝트 템플릿: Windows 데스크톱 마법사에서 콘솔 애플리케이션
      </p>
      <p>
        헤더 파일: Windows.h
      </p>
      <p>
        Windows.h에는 전처리기 매크로와 타입들이 많이 쓰여서, 윈도우 버전에 상관없이 같은 동작을 보장해준다. 
        그 예로 <code>WINAPI</code>, <code>HINSTANCE</code>, <code>_IN_</code> 등이 있다. 
        IntelliSense의 Quick Info 기능을 쓰면 매크로와 타입의 정의를 볼 수 있다. 
        궁금한 단어를 클릭하고, Ctrl+K, Ctrl+I를 누르면 된다. 
      </p>
      <p>
        창을 만들려면 <code>WinMain</code> 함수를 정의한다. 
        <code>WinMain</code> 함수의 첫번째 인자가 <code>HINSTANCE</code> 타입인데, 
        이 인자는 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winmain">현재 앱을 의미하는 핸들</a>이 된다. 
        <code>WinMain</code>에서 제일 먼저 하는 일은 창 관련 설정인 <code>WNDCLASSEX</code> 
        구조체 변수에 창 정보를 저장하는 것인데, 여기서 <code>.hInstance</code>에 첫번째 인자를 저장한다. 
        그 외에 이벤트 발생시 호출할 함수, 커서 등 다른 정보들도 저장한다. 
        그리고, <code>RegisterClassEx</code>함수의 파라미터로 구조체의 포인터를 전달해서 실행하면
        윈도우 운영체제에 현재 어플리케이션과 창 정보가 등록된다. 
        그리고나서, <code>CreateWindowEx</code>에 현재 앱 핸들, 윈도우 제목 등의 정보를 전달해서 
        실행하면, 창이 만들어지고, 리턴값으로 창 핸들을 받는다. 
        <code>ShowWindow</code> 함수에 창 핸들을 전달해서 실행하면 창이 보인다. 
      </p>
    </p>
    <h2> 후크 개요 </h2>
    <p> 공부한 자료:
      <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-hooks">
        Microsoft Learn -> Windows -> 앱 -> Win32 -> Desktop Technologies -> Desktop App User Interface -> Windows and Messages -> 후크 개요
      </a>
    </p>
    <p> 
      후크란 앱이 마우스, 키보드, 메시지와 같은 이벤트들을 인터셉트하게 해주는 방법이다. 
      후크 함수로 이벤트를 받은 다음에 변형하거나 없앨 수도 있다. 
      후크가 쓰이는 경우는, 디버깅, 매크로, F1 키 헬프 메뉴, 마우스/키보드 입력, 트레이닝 앱이 있다.
      후크는 컴퓨터를 느리게 만들기 때문에 최소한만 쓰고 가능한 빨리 제거해야 한다. 
      후크 체인, 후크 함수, 후크 종류에 대해 이어서 설명한다. 
    </p>
    <h3> 후크 체인 </h3>
    <p>
      메시지 종류별로 후크가 다루는 방식이 다르다. 
      예를 들어 <code>WH_MOUSE</code> 후크는 마우스 메시지를 처리한다. 
      각 후크 타입은 별도의 후크 체인으로 관리되는데, 
      여기서 후크 체인은 후크 함수라고 불리는 앱에서 정의된 함수들에 대한 포인터들의 리스트다. 
      특정 후크 타입의 메시지가 발생하면, 시스템에서는 해당 메시지를 후크 체인에 있는 후크 함수들에
      하나씩 전달한다. 
      어떤 후크 타입의 후크 함수들은 메시지를 읽을 수만 있고, 다른 후크 타입에 대한 후크 함수들은 
      메시지를 변경하거나, 나머지 후크 체인에 전달되지 않게 할 수 있다. 
    </p>
    <h3> 후크 함수 </h3>
    <p> 
      특정 후크 타입을 쓰기 위해, 개발자는 후크 함수를 만들고, <code>SetWindowsHookEx</code> 함수를
      써서 후크 체인에 이를 설치한다. 후크 함수는 다음과 같은 문법을 따라야 한다. 
    </p>
    <code><pre>
      LRESULT CALLBACK HookProc(
        int nCode,
        WPARAM wParam,
        LPARAM lParam
      )
      {
        // 이벤트 처리
        ...

        return CallNextHookEx(NULL, nCode, wParam, lParam);
      }
    </pre></code>
    <p> <code>HookProc</code>은 앱에서 정의된 이름이 들어갈 자리를 표시하고 있다. </p>
    <p> 
      <code>nCode</code>, <code>wParam</code>, <code>lParam</code>은 후크 종류마다 다른데, 
      보통 <code>nCode</code>는 후크 함수가 어떤 상황에 대한 일을 할지 정해주는 코드고, 
      <code>wParam</code>과 <code>lParam</code>은 메시지 관련 정보가 들어간다. 
    </p>
    <p>
      <code>CallNextHookEx</code>를 호출하면 이벤트를 다음 후크 함수에게 넘겨준다.
    </p>

    <p>
      <code>SetWindowsHookEx</code>는 인자로 받은 후크 함수를 항상 후크 체인의 제일 앞에 설치한다.
      어떤 후크 종류는 메시지를 관찰만 할 수 있기 때문에 <code>CallNextHookEx</code>를 호출했는지
      여부와 관계 없이 메시지를 다음 후크 함수에게 전달하지만, 다른 후크 종류에서는 
      <code>CallNextHookEx</code>를 호출하지 않으면 다음 후크 함수가 실행되지 않는다. 
    </p>

    <h3> 후크 타입 </h3>
    <p>
      <code>WH_CBT</code> 후크 함수는 창의 상태나 크기가 바뀌기 전, 시스템 명령어 실행 전, 
      마우스, 키보드 이벤트를 끝내기 전, 입력 포커스를 설정하기 전에 호출된다. 컴퓨터 기반 트레이닝
      앱을 위해 만들어졌다. 
    </p>

    <p>
      <code>WH_KEYBOARD_LL</code> 후크 함수는 키보드 입력 이벤트가 쓰레드에서 처리되기 전에 
      먼저 확인할 수 있게 해준다. 
    </p>

    <p>
      <code>WH_KEYBOARD</code> 후크 함수는 키보드 입력 이벤트를 관찰할 수 있게 해준다.
    </p>

    <p>
      <code>WH_MOUSE_LL</code> 후크 함수는 마우스 입력 이벤트가 처리되기 전에 확인하게 해준다.
    </p>

    <p>
      <code>WH_MOUSE</code> 후크 함수는 마우스 입력 이벤트를 관찰할 수 있게 해준다. 
    </p>
    
    <h2> 후크 쓰기 </h2>
    <p> 공부한 자료:
      <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/using-hooks">
        Microsoft Learn -> Windows -> 앱 -> Win32 -> Desktop Technologies -> Desktop App User Interface -> Windows and Messages
      </a>      
    </p>
    <h3> 후크 설치하고 해제하기 </h3>
    <p>
      <code>SetWindowsHookEx</code> 함수를 호출해서 후크 함수를 설치할 수 있고, 이 때 
      어떤 후크가 후크 함수를 실행할지, 후크 함수가 어떤 쓰레드에 결합될지, 후크 함수의 포인터가
      매개변수로 전달된다.
    </p>
    <p>
      <code>UnhookWindowsHookEx</code> 함수를 호출해서 설치된 후크 함수를 제거할 수 있다. 
    </p>

    <h2> Copilot이 만든 예제 </h2>
    <pre><code>
      #include &lt;windows.h&gt;
      #include &lt;stdio.h&gt;

      LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
        if (nCode == HC_ACTION) {
          KBDLLHOOKSTRUCT* pKeyBoard = (KBDLLHOOKSTRUCT*) lParam;
          if (wParam == WM_KEYDOWN) {
            printf("Key down: %d\n", pKeyBoard->vkCode);
          }
          else if (wParam == WM_KEYUP) {
            printf("Key up: %d\n", pKeyBoard->vkCode);
          }
        }
        return CallNextHookEx(NULL, nCode, wParam, IParam);
      }

      int main() {
        HHOOK hhook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, NULL, 0);
        MSG msg;
        while (GetMessage(&msg, NULL, 0, 0) > 0) {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
        }
        UnhookWindowsHookEx(hhook);
        return 0;
      }
    </code></pre>

    <h3><a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/lowlevelkeyboardproc">LowLevelKeyboardProc 함수</a></h3>
    <p>
      LowLevelKeyboardProc는 SetWindowsHookExW을 호출할때 콜백 함수로 전달된다. 
      인자로는 int nCode, WPARAM wParam, LPARAM lParam을 받는다. 
      nCode가 0보다 작으면, CallNextHookEx를 호출해야한다. 
      nCode의 값은 HC_ACTION(0)만 가질 수 있다. 
      wParam은 키보드 메시지의 종류를 뜻한다. 
      wParam의 값은 WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, 
      WM_SYSKEYUP 중 하나가 된다. 
      lParam은 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-kbdllhookstruct">KBDLLHOOKSTRUCT</a> 구조체의 포인터다. 
      KBDLLHOOKSTRUCT의 구조는 vkCode, scanCode, flags, time, dwExtraInfo다. 
      vkCode는 1부터 254까지 범위의 키보드의 키에 해당하는 숫자다. 
      scanCode는 키에 대한 하드웨어 코드다. 
      flags는 ALT가 눌렸는지, 확장키인지 등의 정보를 준다. 
      time은 메시지의 시간을 보내준다. 
      dwExtraInfo는 추가 메시지를 보내준다. 
    </p>
    <p>
      <code>WH_KEYBOARD_LL</code> 타입의 훅은 이를 설치한 쓰레드의 
      맥락에서 호출된다. 
      호출되는 방식은 이를 설치한 쓰레드에 메시지를 전달하는 것이다. 
      그래서 후크를 설치한 쓰레드에는 메시지 루프가 있어야 한다. 
    </p>
    <p>
      키보드 입력은 로컬 키보드 드라이버에서 올 수 있고,
      <code>keybd_event</code> 함수에서도 호출될 수 있다. 
      보통 주어진 최대 처리 시간은 1초다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-callnexthookex">
        CallNextHookEx
      </a> 함수는 후크 체인에서 다음 함수로 넘어간다. 
    </h3>
    <p>
      인수로는 HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam이 있다. 
      hhk 파라미터는 무시된다. 
      nCode는 후크 정보를 어떻게 해석할지에 대한 코드다. 
      wParam과 lParam에는 현재 후크에 대한 정보가 들어있다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexw">
        SetWindowsHookExW
      </a> 함수는 후크 함수를 설치한다.
    </h3>
    <p>
      인수는 int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId다.
      idHook 파라미터는 어떤 후크인지를 뜻한다. 
      lpfn 파라미터는 후크 함수에 대한 포인터다. 
      hmod 파라미터는 lpfn 후크 함수가 정의된 DLL에 대한 핸들이다. 
      dwThreadId 파라미터는 후크 함수가 연결된 쓰레드를 뜻한다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage">
        GetMessage
      </a> 함수는 메시지 큐에서 메시지를 꺼내온다. 
    </h3>
    <p>
      매개변수는 LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax다. 
      lpMsg는 메시지 정보를 저장할 구조체의 포인터다. 
      hWnd는 메시지를 받으려는 창에 대한 핸들이다. 
      NULL일 때 현재 스레드에 속한 모든 윈도우의 메시지를 받는다. 
      wMsgFilterMin, wMsgFilterMax는 처리할 메시지 번호의 
      최소값, 최대값이다. 모두 0으로 설정하면 모든 메시지를 받는다. 
      리턴값은 메시지가 WM_QUIT일 때 0이고, 그렇지 않으면 0이 아니다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage">
        TranslateMessage
      </a> 함수는 가상 키에서 키보드 문자를 해석한다.  
    </h3>
    <p>
      매개변수는 MSG *lpMsg를 받는다. 
      번역을 했을 때만 0이 아닌 값을 리턴한다.
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessage">
        DispatchMessage
      </a> 함수는 메시지에 해당하는 창의 후크 함수를 실행한다.  
    </h3>
    <p>
      매개변수는 MSG *lpMsg를 받는다. 
      후크 함수에서 리턴한 값을 리턴하며, 보통 쓰이지 않는다. 
    </p>
    <h2>
      <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues?source=recommendations">
        메시지와 메시지 큐
      </a>
    </h2>
    <p>
      MS-DOS 앱에서는 입력을 받기 위해서 함수 호출을 했다. 
      창이 있는 앱들은 이벤트를 쓰기 때문에, 시스템이 입력을 전달해주기를 기다린다. 
      시스템은 앱의 다양한 창에 입력을 전달해준다. 
      각각의 창은 함수를 가지고 있어서, 시스템이 입력을 전달할 때 해당 함수를 호출한다. 
      가장 앞에 있는 창이 몇초 이상 메시지에 반응하지 않으면, 
      시스템은 그 창이 응답하지 않는다고 본다. 
    </p>
    <h3>
      윈도우 메시지
    </h3>
    <p>
      시스템은 윈도우 함수에 입력을 전달할 때 메시지 형태로 한다. 
      메시지는 시스템과 앱에서 만들 수 있다. 
      시스템이 메시지를 만들 때는, 마우스, 키보드 입력이 있을 때, 
      그리고 앱에서 창 크기나 시스템 폰트를 바꿀 때 등이다. 
      앱이 메시지를 만들 때는, 자신의 또는 다른 앱의 창을 조절할 때다. 
    </p>
    <h2>
      <a href="https://learn.microsoft.com/ko-kr/windows/win32/winmsg/using-timers">
        타이머: Microsoft Learn -> 윈도우 -> 앱 -> Win32 -> 데스크톱 기술 -> 데스크톱 앱 사용자 인터페이스 -> 창 및 메시지
      </a>
    </h2>
    <h3> 타이머 만들기 </h3>
    <p>
      타이머를 만들 때는 <code>SetTimer</code> 함수를 쓴다. 
    </p>
    <h3> 
      <a href="https://learn.microsoft.com/ko-kr/windows/win32/api/winuser/nf-winuser-settimer">
        <code>SetTimer</code> 함수
      </a>
    </h3>
    <p>
      매개변수는 HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMEPROC lpTimerFunc다. 
      hWnd는 창에 대한 핸들이며, NULL도 가능하다. 
      nIDEvent는 타이머 ID다. 
      uElapse는 밀리초 단위 제한시간이다. 
      lpTimerFunc은 함수 포인터고, NULL이면 앱 큐에 WM_TIMER가 들어온다. 
      리턴 값은 hWnd가 NULL일 때 새 타이머 ID를 준다. 
    </p>
    <p>
      hWnd 매개 변수가 NULL이고 nIDEvent가 기존 타이머에 없는 경우, 
      전달된 nIDEvent는 무시되고, 새 타이머 ID가 생성되고 반환된다. 
      SetTimer가 타이머를 바꾸면 이전에 설정한 제한 시간 값이 무시된다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/ko-kr/windows/win32/api/winuser/nc-winuser-timerproc?source=recommendations">
        <code>TIMERPROC</code> 콜백 함수
      </a>
    </h3>
    <p>
      매개변수는 HWND unnamedParam1, UINT unnamedParam2, UINT_PTR unnamedParam3, DWORD unnamedParam4다. 
      반환 값은 없다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-killtimer">
        <code>KillTimer</code> 함수
      </a>
    </h3>
    <p>
      지정한 타이머를 제거한다. 
      매개변수는 HWND hWnd, UINT_PTR nIDEvent다. 
      hWnd는 타이머가 설정된 창으로 없으면 NULL을 입력한다. 
      nIDEvent는 타이머 ID와 같아야 한다.
    </p>
    <h2>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-sendinput">
        <Code>SendInput</Code> 함수는 키보드, 마우스 입력을 만든다.
      </a>
    </h2>
    <p>
      매개변수는 UINT cInputs, LPINPUT pInputs, int cbSize다. 
      cInputs는 pInputs에 요소가 몇개 있는지를 뜻한다. 
      pInputs는 INPUT 구조체의 배열이다.
      cbSize는 INPUT 구조체가 몇 바이트인지다. 
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-input">
        <code>INPUT</code>> 구조체
      </a>
    </h3>
    <p>
      요소는 DWORD type, MOUSEINPUT mi다. 
      MOUSEINPUT mi 대신 KEYBDINPUT ki를 쓸 수도 있다. 
      type의 값은 INPUT_MOUSE, INPUT_KEYBOARD, INPUT_HARDWARE가 가능하다.
    </p>
    <h3>
      <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-mouseinput">
        MOUSEINPUT 구조체 
      </a>
    </h3>
    <p>
      요소는 dx, dy, mouseData, dwFlags, time, dwExtraInfo가 있다. 
      dx는 x 상대/절대 좌표다. 
      dy는 y 상대/절대 좌표다. 
      mouseData는 dwData가 휠, X 관련이 아닌 이상 0이어야 한다. 
      dwFlags는 MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP 등이 가능하다. 
      time은 이벤트 발생 시간이다. 
    </p>

    <h1> HTML 5일차 </h1>
      <p> 예제 코드: <code>&lt;meta name="description" content="accessed by bot" /&gt;</code></p> 
      <p> 실행 결과: 검색 엔진에서 접근가능하다. </p>
  
      <p>
        <code> name </code> 속성과 <code> contents </code> 속성을 지정하는 방식으로
        어떤 종류의 메타데이터가 무엇이라고 정할 수 있다.
      </p>

    <h2> 파비콘 </h2>
      <p> <code>&lt;link rel="icon" href="favicon.ico" type="image/x-icon" /&gt;</code> </p>
      <p> 제목 왼쪽의 아이콘을 정해준다. </p>

    <h3> 
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link">
        link
      </a> 요소
    </h3>

    <p>
      현재 문서와 외부 자원 간의 관계를 지정해준다. 
    </p>

    <p>
      예제 코드: &lt;link href="main.css" rel="stylesheet" /&gt;
    </p>

    <p>
      실행 결과: main.css 파일이 CSS로 로드된다. 
    </p>

    <h2>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">
        script
      </a> 요소
    </h2>

    <p>
      자바스크립트 코드를 쓴다. 속성으로 src가 있다. 
      src 속성은 외부 자바스크립트 코드를 읽게 해준다. 
    </p>

    <h1> C 5일차 - C2y standard </h1>
    <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
    <h2> Pvii </h2>

    <p> 7. 라이브러리 </p>
    <p> 7.1 서론 </p>
    <p> 7.1.1 용어의 정의 </p>
    <p> 7.1.2 표준 헤더 </p>
    <p> 7.1.3 예약된 식별자 </p>
    <p> 7.1.4 라이브러리 함수의 사용 </p>
    <p> 7.2 진단 &lt;assert.h&gt;</p>
    <p> 7.2.1 일반 </p>
    <p> 7.2.2 프로그램 진단 </p>
    <p> 7.3 복소수 연산 &lt;complex.h&gt;</p>
    <p> 7.3.1 서론 </p>
    <p> 7.3.2 규칙 </p>
    <p> 7.3.3 각의 범위 제한하기 </p>
    <p> 7.3.4 CX_LIMITED_RANGE 컴파일러 지시자 </p>
    <p> 7.3.5 삼각 함수 </p>
    <p> 7.3.6 쌍곡선 함수 </p>
    <p> 7.3.7 지수 및 로그 함수 </p>
    <p> 7.3.8 멱함수 및 절대값 함수 </p>
    <p> 7.3.9 조작 함수 </p>
    <p> 7.4 문자 처리 함수 &lt;ctype.h&gt; </p>
    <p> 7.4.1 일반 </p>
    <p> 7.4.2 문자 분류 함수 </p>
    <p> 7.4.3 문자 대소문자 변환 함수 </p>
    <p> 7.5 에러 &lt;errno.h&gt; </p>
    <p> 7.6 부동소수점 환경 &lt;fenv.h&gt;</p>
    <p> 7.6.1 일반 </p>
    <p> 7.6.2 FENV_ACCESS 컴파일러 지시자 </p>
    <p> 7.6.3 FENV_ROUND 컴파일러 지시자 </p>
    <p> 7.6.4 FENV_DEC_ROUND 컴파일러 지시자 </p>
    <p> 7.6.5 부동소수점 예외 </p>
    <p> 7.6.6 반올림 및 기타 조절 모드 </p>
    <p> 7.6.7 환경 </p>
    <p> 7.7 부동소수점 타입의 특징 &lt;float.h&gt;</p>
    <p> 7.8 정수 타임의 포맷 변경 &lt;inttypes.h&gt;</p>
    <p> 7.8.1 일반 </p>
    <p> 7.8.2 포맷 지정자 매크로 </p>
    <p> 7.8.3 가장 큰 정수 타입을 위한 함수 </p>
    <p> 7.9 다른 철자법 &lt;iso646.h&gt;</p>
    <p> 7.10 정수 타입의 특성 &lt;limits.h&gt;</p>
    <p> 7.11 지역화 &lt;locale.h&gt;</p>

    <h1> HTML 6일차 </h1>
    <h3> 문서의 언어 설정하기 </h3>
    <p>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang">
        lang 전역 속성
      </a>
    </p>
    <p> 화면 읽는 기계 등에서 알 수 있게 언어를 정해준다. </p>

    <h2> 
      <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Headings_and_paragraphs">
        HTML에서 제목과 문단
      </a>
    </h2>

    <h3>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p">
        p 요소
      </a>는 각 문단을 표시한다.
    </h3>

    <p> 예제 코드: 
      &lt;p&gt; ...문단 내용... &lt;/p&gt; 
    </p>

    <p> 실행 결과: <p> ...문단 내용... </p> </p>

    <h3>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements">
        h1, h2, ... , h6 요소
      </a>는 제목을 표시한다. 
    </h3>

    <p> 예제 코드:
      &lt;h1&gt; _제목_ &lt;/h1&gt; 
    </p>

    <p> 실행 결과: <h1> _제목_ </h1> </p>

    <h1> C 6일차 - C2y standard </h1>
    <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
    <h2> Pviii </h2>

    <p> 7.11.1 일반</p>
    <p> 7.11.2 setlocale 함수 </p>
    <p> 7.11.3 숫자 포맷팅 방법 설문조사 </p>
    <p> 7.12 수학 &lt;math.h&gt; </p>
    <p> 7.12.1 일반 </p>
    <p> 7.12.2 에러 조건 처리 </p>
    <p> 7.12.3 FP_CONTRACT 컴파일러 지시자 </p>
    <p> 7.12.4 매크로 분류 </p>
    <p> 7.12.5 삼각 함수 </p>
    <p> 7.12.6 쌍곡선 함수 </p>
    <p> 7.12.7 지수 및 로그 함수 </p>
    <p> 7.12.8 멱함수와 절대값 함수 </p>
    <p> 7.12.9 에러 및 감마 함수 </p>
    <p> 7.12.10 반올림 함수 </p>
    <p> 7.12.11 나머지 함수 </p>
    <p> 7.12.12 조작 함수 </p>
    <p> 7.12.13 최대, 최소, 차이 함수 </p>
    <p> 7.12.14 곱셈-덧셈 합성함수 </p>
    <p> 7.12.15 더 작은 자료형으로 반올림하는 함수 </p>
    <p> 7.12.16 양자화 함수, 양자지수함수 </p>
    <p> 7.12.17 십진수를 다시 인코딩하는 함수 </p>
    <p> 7.12.18 비교 매크로 </p>
    <p> 7.13 지역을 벗어나는 점프 &lt;setjmp.h&gt; </p>
    <p> 7.13.1 일반 </p>
    <p> 7.13.2 호출 환경 저장 </p>
    <p> 7.13.3 호출 환경 불러오기 </p>
    <p> 7.14 신호 핸들링 &lt;signal.h&gt; </p>
    <p> 7.14.1 일반 </p>
    <p> 7.14.2 신호 처리 방법 지정 </p>
    <p> 7.14.3 신호 전달 </p>
    <p> 7.15 정렬 &lt;stdalign.h&gt; </p>
    <p> 7.16 다양한 인자 &lt;stdarg.h&gt; </p>
    <p> 7.16.1 일반 </p>
    <p> 7.16.2 다양한 인자를 쓸 때 인자의 값을 읽는 매크로 </p>
    <p> 7.17 원자 &lt;stdatomic.h&gt; </p>
    <p> 7.17.1 서론 </p>
    <p> 7.17.2 초기화 </p>
    <p> 7.17.3 순서와 일관성 </p>
    <p> 7.17.4 메모리 장벽 </p>
    <p> 7.17.5 락이 없어도 되는 속성 </p>

    <h1> ML 1일차 - MNIST 숫자 손글씨 이미지 </h1>
    <p> 공부한 자료: 
      <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/MNIST-SPM2012.pdf">
        The MNIST Database of Handwritten Digit Images for Machine Learning Research
      </a>, Li Deng, <i>IEEE Signal Processing Magazine best of THE WEB</i>, 2012
    </p>

    <p> 
      MNIST: modified National Institute of Standards and Technology 
      (미국국립표준기술연구소의 변형). 손으로 쓴 숫자 이미지로 
      문자 인식과 기계 학습 연구에서 많이 쓰이고 있음. 무료임.
    </p>

    <p> 
      데이터 주소: <a href=" http: //yann.lecun.com/exdb/mnist">
        http: //yann.lecun.com/exdb/mnist
      </a>. 접속에 어려움 있음.
    </p>

    <p>
      MNIST 데이터베이스는 NIST 데이터베이스로부터 제작됨.
      학습할 이미지 60,000개, 테스트할 이미지 10,000개 있음. 
      모두 흑백이고, 가로 세로 28개 픽셀, 가운데 정렬 됨. 
    </p>

    <p>
      기계 학습 알고리즘들에 대한 평가도 같은 홈페이지에서 보여줌. 
      기계 학습 테크닉은 크게 다음과 같이 분류됨:  
      선형 분류, k개 가장 가까운 지역, 여러 모델 결합, 
      비선형 분류, 최적화, 신경망, 필터된 신경망.
    </p>

    <p>
      다른 방법들 중 신경망 분류기가 주로 성능이 높은 편임. 
      필터된 신경망이 성능이 가장 높음. 
      딥러닝으로 10,000개 테스트 이미지 중 35개 에러 달성. 
      데이터에 변형을 주는 것이 에러율을 낮추는데 중요함. 
      변형 없이는 53개로 에러 증가. 
      신경망의 깊이가 얕으면 에러가 110개로 증가. 
    </p>

    <p>
      신경망 분류기 다음으로는 k개 가장 가까운 지역 방법과 
      가상 최적화 방법이 정확하게 분류
    </p>
  </body>

  <h1> HTML 7일차 </h1>
  <h2> 
    <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Emphasis_and_importance">
      강조와 굵게 표시
    </a>
  </h2>

  <p> 제목과 내용의 글자를 강조하고 굵게 표시하는 방법 </p>

  <h3>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em">
      &lt;em&gt; 
    </a>
    요소로 글자를 강조할 수 있다. 
  </h3>

  <p> 예제 코드: &lt;p&gt;em은 글자를 &lt;em&gt;강조&lt;/em&gt;한다.&lt;/p&gt;</p>
  <p> 실행 결과: </p>
  <p> em은 글자를 <em>강조</em>한다. </p>

  <h3>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong">
      &lt;strong&gt;
    </a> 
    요소로 글자를 강하게 표시한다.
  </h3>

  <p> 예제 코드: &lt;p&gt;strong은 글자를 &lt;strong&gt;강하게&lt;/strong&gt; 표시한다.&lt;/p&gt;</p>
  <p> 실행 결과: </p>
  <p> strong은 글자를 <strong>강하게</strong> 표시한다. </p>

  <h3>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i">
      &lt;i&gt;
    </a>는 기울임꼴, 
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b">
      &lt;b&gt;
    </a>는 굵게 표시,
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u">
      &lt;u&gt;
    </a>는 밑줄이다. 
  </h3>

  <p> 
    하지만, 스크린을 읽어주는 기계에서는 em과 strong만 취급하므로,
    i, b, u 요소는 쓰지 않는 것이 좋다. 
    특별한 의미 없이 스타일만 바꿀 때는 CSS를 쓴다.
  </p>

  <h1> C 2일차 - GNU C 언어 매뉴얼 </h1>
  <p> 공부한 자료: <a href="https://www.gnu.org/software/c-intro-and-ref/manual/html_node/index.html">International Standard Organization의 C23 standard</a> </p>

  <p> 12. 상수 </p>
  <p> 12.1 정수 상수 </p>
  <p> 12.2 정수 상수 자료형 </p>
  <p> 12.3 부동소수점 상수 </p>
  <p> 12.4 허수 상수 </p>
  <p> 12.5 부적합한 숫자 </p>
  <p> 12.6 문자 상수 </p>
  <p> 12.7 문자열 상수 </p>
  <p> 12.8 UTF-8 문자열 상수 </p>
  <p> 12.9 유니코드 문자 코드 </p>
  <p> 12.10 확장 문자 </p>
  <p> 12.11 확장 문자열 상수 </p>
  <p> 13. 자료형 크기 </p>
  <p> 14. 포인터 </p>
  <p> 14.1 자료 주소 </p>
  <p> 14.2 포인터 자료형 </p>
  <p> 14.3 포인터 변수 선언 </p>
  <p> 14.4 포인터 지정자 </p>
  <p> 14.5 포인터 역참조 </p>
  <p> 14.6 Null 포인터 </p>
  <p> 14.7 Null 또는 부적합 포인터 역참조 </p>
  <p> 14.8 Void 포인터 </p>
  <p> 14.9 포인터 비교 </p>
  <p> 14.10 포인터 산수 </p>
  <p> 14.11 포인터와 배열 </p>
  <p> 14.12 저수준 포인터 산수 </p>
  <p> 14.13 포인터 증가와 감소 </p>
  <p> 14.14 포인터 산수의 문제 </p>
  <p> 14.15 포인터-정수 형변환 </p>
  <p> 14.16 포인터 출력 </p>
  <p> 15. 구조체 </p>
  <p> 15.1 구조체 필드 접근 </p>
  <p> 15.2 배열을 필드로 쓰기 </p>
  <p> 15.3 동적 메모리 할당 </p>
  <p> 15.4 필드 오프셋 </p>
  <p> 15.5 구조체 레이아웃 </p>
  <p> 15.6 패킹된 구조체 </p>
  <p> 15.7 비트 필드 </p>
  <p> 15.8 비트 필드 패킹 </p>
  <p> 15.9 상수 필드 </p>
  <p> 15.10 길이가 0인 배열 </p>
  <p> 15.11 가변 배열 필드 </p>
  <p> 15.12 다른 구조체를 겹치기 </p>
  <p> 15.13 구조체 대입 </p>
  <p> 15.14 공용체 </p>
  <p> 15.15 공용체 패킹하기 </p>
  <p> 15.16 공용체 자료형으로의 형변환 </p>
  <p> 15.17 구조체 생성자 </p>
  <p> 15.18 이름 없는 자료형을 필드로 쓰기 </p>
  <p> 15.19 미완성 자료형 </p>
  <p> 15.20 얽혀있는 미완성 자료형 </p>
  <p> 15.21 자료형 태그 </p>
  <p> 16. 배열 </p>
  <p> 16.1 배열 요소에 접근 </p>
  <p> 16.2 배열 선언하기 </p>
  <p> 16.3 문자열 </p>
  <p> 16.4 배열 자료형 지정자 </p>
  <p> 16.5 미완성 배열 자료형 </p>
  <p> 16.6 C 배열의 한계 </p>
  <p> 16.7 다차원 배열 </p>
  <p> 16.8 배열 값 생성 </p>
  <p> 16.9 가변 크기 배열 </p>
  <p> 17. 열거형 </p>
  <p> 18. 자료형 이름 정의 </p>
  <p> 19. 문장 </p>
  <p> 19.1 수식 문장 </p>
  <p> 19.2 <code>if</code> 문장 </p>
  <p> 19.3 <code>if-else</code> 문장 </p>
  <p> 19.4 블록 </p>
  <p> 19.5 <code>return</code> 문장 </p>
  <p> 19.6 반복 문장 </p>
  <p> 19.6.1 <code>while</code> 문장 </p>
  <p> 19.6.2 <code>do-while</code> 문장 </p>
  <p> 19.6.3 <code>break</code> 문장 </p>
  <p> 19.6.4 <code>for</code> 문장 </p>
  <p> 19.6.5 <code>for</code>의 예제 </p>
  <p> 19.6.6 생략된 <code>for</code> 수식 </p>
  <p> 19.6.7 <code>for</code>-인덱스 선언 </p>
  <p> 19.6.8 <code>continue</code> 문장 </p>
  <p> 19.7 <code>switch</code> 문장 </p>
  <p> 19.8 <code>switch</code> 예제 </p>
  <p> 19.9 <code>더프</code>의 장치 </p>
  <p> 19.10 Case의 범위 </p>
  <p> 19.11 Null 문장 </p>
  <p> 19.12 <code>goto</code> 문장과 라벨 </p>
  <p> 19.13 지역적으로 선언된 라벨 </p>
  <p> 19.14 라벨을 값으로 쓰기 </p>
  <p> 19.14.1 라벨 값의 쓰임 </p>
  <p> 19.14.2 라벨 값을 쓸 때 주의사항 </p>
  <p> 19.15 수식 안에서의 문장과 선언 </p>
  <p> 20. 변수 </p>
  <p> 20.1 변수 선언 </p>
  <p> 20.1.1 배열과 포인터 선언 </p>
  <p> 20.1.2 변수 선언 합치기 </p>
  <p> 20.2 초기화자 </p>
  <p> 20.3 지정된 초기화자 </p>
  <p> 20.4 <code>__auto_type</code>으로 타입 부르기 </p>
  <p> 20.5 지역 변수 </p>
  <p> 20.6 파일범위 변수 </p>
  <p> 20.7 정적 지역 변수 </p>
  <p> 20.8 <code>extern</code> 선언 </p>
  <p> 20.9 파일범위 변수 할당 </p>
  <p> 20.10 <code>auto</code>와 <code>register</code> </p>
  <p> 20.11 선언에서 타입 생략하기 </p>
  <p> 21. 타입 한정자 </p>
  <p> 21.1 <code>const</code> 변수와 필드 </p>
  <p> 21.2 <code>volatile</code> 변수와 필드 </p>
  <p> 21.3 <code>restrict</code>로 한정된 포인터 </p>
  <p> 21.4 <code>restrict</code> 포인터 예제 </p>
  <p> 22. 함수 </p>
  <p> 22.1 함수 정의 </p>
  <p> 22.1.1 함수의 매개변수 </p>
  <p> 22.1.2 전방 함수 선언 </p>
  <p> 22.1.3 정적 함수 </p>
  <p> 22.1.4 배열을 매개변수로 쓰기 </p>
  <p> 22.1.4.1 배열 매개변수는 포인터다 </p>
  <p> 22.1.4.2 배열 인자 전달하기 </p>
  <p> 22.1.4.3 배열 매개변수에 대한 타입 한정자 </p>
  <p> 22.1.5 구조체 인자를 받을 수 있는 함수 </p>
  <p> 22.2 함수 선언 </p>
  <p> 22.3 함수 호출 </p>
  <p> 22.4 함수 호출 의미 </p>
  <p> 22.5 함수 포인터 </p>
  <p> 22.5.1 함수 포인터 선언하기 </p>
  <p> 22.5.2 함수 포인터 대입하기 </p>
  <p> 22.5.3 함수 포인터 호출하기 </p>
  <p> 22.6 <code>main</code> 함수 </p>
  <p> 22.6.1 <code>main</code> 함수에서 값 반환하기 </p>
  <p> 22.6.2 명령행 인자에 접근하기 </p>
  <p> 22.6.3 환경 변수에 접근하기 </p>
  <p> 22.7 고급 함수 기능 </p>
  <p> 22.7.1 가변 길이 배열 매개변수 </p>
  <p> 22.7.2 가변 길이 매개변수 리스트 </p>
  <p> 22.7.3 함수 안의 함수 </p>
  <p> 22.7.4 같은 줄에 들어가는 함수의 정의 </p>
  <p> 22.8 구식 함수 기능 </p>
  <p> 22.8.1 구식 GNU C에서 함수를 같은 줄에 넣는 방법 </p>
  <p> 22.8.2 구식 함수 정의 </p>
  <p> 23 호환 가능한 타입 </p>
  <p> 24 타입 변환 </p>
  <p> 24.1 명시적 타입 변환 </p>
  <p> 24.2 대입시 타입 변환 </p>
  <p> 24.3 인자에서 확장 변환 </p>
  <p> 24.4 피연산자에서 확장 변환 </p>
  <p> 24.5 공통 타입 </p>
  <p> 25 범위 </p>
  <p> 26 전처리 </p>
  <p> 26.1 전처리 개요 </p>
  <p> 26.2 지시자 </p>
  <p> 26.3 전처리 토큰 </p>
  <p> 26.4 헤더 파일 </p>
  <p> 26.4.1 <code>#include</code> 문법 </p>
  <p> 26.4.2 <code>#include</code>의 동작 </p>
  <p> 26.4.3 검색 경로 </p>
  <p> 26.4.4 한번만 포함되는 헤더 </p>
  <p> 26.4.5 계산된 포함 </p>
  <p> 26.5 매크로 </p>
  <p> 26.5.1 객체 같은 매크로 </p>
  <p> 26.5.2 함수 같은 매크로 </p>
  <p> 26.5.3 매크로 인자 </p>
  <p> 26.5.4 문자열화 </p>
  <p> 26.5.5 이어붙이기 </p>
  <p> 26.5.6 가변 매크로 </p>
  <p> 26.5.7 미리 정의된 매크로 </p>
  <p> 26.5.8 매크로 지우거나 재정의하기 </p>
  <p> 26.5.9 매크로 인자 내의 지시자 </p>
  <p> 26.5.10 매크로의 위험성 </p>
  <p> 26.5.10.1 잘못된 중첩 </p>
  <p> 26.5.10.2 연산자 우선순위 문제 </p>
  <p> 26.5.10.3 세미콜론 삼킴 </p>
  <p> 26.5.10.4 대입 중복 </p>
  <p> 26.5.10.5 <code>__auto_type</code>을 지역 변수들에 쓰기 </p>
  <p> 26.5.10.6 스스로를 참조하는 매크로 </p>
  <p> 26.5.10.7 인자를 미리 스캔하기 </p>
  <p> 26.6 조건부 </p>
  <p> 26.6.1 조건부 지시자 사용 </p>
  <p> 26.6.2 조건부 전처리 문법 </p>
  <p> 26.6.2.1 <code>#ifdef</code> 지시자 </p>
  <p> 26.6.2.2 <code>#if</code> 지시자 </p>
  <p> 26.6.2.3 <code>#defined</code> 테스트 </p>
  <p> 26.6.2.4 <code>#else</code> 지시자 </p>
  <p> 26.6.2.5 <code>#elif</code> 지시자 </p>
  <p> 26.6. 삭제된 코드 </p>
  <p> 26.7 문제 해결 </p>
  <p> 26.8 줄 제어 </p>
  <p> 26.9 Null 지시자 </p>
  <p> 27. 정수에 대한 자세한 내용 </p>
  <p> 27.1 정수가 표현되는 방법 </p>
  <p> 27.2 최대값과 최소값 </p>
  <p> 28 부동 소수점에 대한 자세한 내용 </p>
  <p> 28.1 부동소수점이 표현되는 방법 </p>
  <p> 28.2 부동소수점 타입 지정자 </p>
  <p> 28.3 특별한 부동소수점 값 </p>
  <p> 28.4 부적합한 최적화 </p>
  <p> 28.5 부동소수점 예외 깃발 </p>
  <p> 28.6 정확한 부동소수점 연산 </p>
  <p> 28.7 반올림 </p>
  <p> 28.8 반올림 이슈 </p>
  <p> 28.9 유효숫자 상실 </p>
  <p> 28.10 곱셈-덧셈 결합 </p>
  <p> 28.11 예외 처리 </p>
  <p> 28.12 정확한 부동소수점 상수 </p>
  <p> 28.13 무한대 다루기 </p>
  <p> 28.14 숫자가 아닌 값 다루기 </p>
  <p> 28.15 부호 있는 숫자 영 </p>
  <p> 28.16 밑에 대한 지수로 크기 바꾸기 </p>
  <p> 28.17 반올림 조절 </p>
  <p> 28.18 기계 오차 </p>
  <p> 28.19 복소수 연산 </p>
  <p> 28.20 밑을 바꾼 후 다시 원래대로 바꾸기 </p>
  <p> 28.21 더 읽을거리 </p>
  <p> 29 컴파일 </p>
  <p> 30 컴파일 지시 </p>
  <p> 30.1 프라그마 </p>
  <p> 30.1.1 프라그마 기초 </p>
  <p> 30.1.2 엄격한 프라그마 </p>
  <p> 30.1.3 최적화 프라그마 </p>
  <p> 30.2 정적 확인 </p>
  <p> Appendix A 타입 정렬 </p>
  <p> Appendix B 겹침 </p>
  <p> B.1 정렬과 겹침 </p>
  <p> B.2 겹침과 길이 </p>
  <p> B.3 겹침 관련 타입 규칙 </p>
  <p> Appendix C 자음이중자 </p>
  <p> Appendix D 선언에서의 속성 </p>
  <p> Appendix E 신호 </p>
  <p> Appendix F GNU 무료 문서 라이선스 </p>
  <p> Appendix G GNU 일반 공공 라이선스 </p>
  <p> 기호와 키워드 차례 </p>
  <p> 개념 차례 </p>

  <h1> HTML 8일차 </h1>
  <h2> 
    <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Lists">
      리스트
    </a>
  </h2>

  <p> 리스트를 웹페이지에서 쓸 때 동그라미로, 숫자로, 기호 없이 쓸 수 있다 </p>

  <h3>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul">
      <code>&lt;ul&gt;</code></a>로 동그라미 리스트를 만든다.
  </h3>

  <p> 리스트의 내용은
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li">
      <code>&lt;li&gt;</code></a>로 표시한다. 
  </p>

  <p> 예제 코드: </p>
  <code><pre>
    &lt;ul&gt;
        &lt;li&gt; 동그라미1 &lt;/li&gt;
        &lt;li&gt; 동그라미2 &lt;/li&gt;
        나머지
        동그라미
        없음
    &lt;/ul&gt;
  </pre></code>
  <p> 실행 결과: </p>
  <ul>
    <li> 동그라미1 </li>
    <li> 동그라미2 </li>
    나머지
    동그라미
    없음
  </ul>

  <h3>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol">
      <code>&lt;ol&gt;</code></a>로 숫자 리스트를 만든다. 
  </h3>
    
  <p> 여기서도 리스트의 내용은
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li">
      <code>&lt;li&gt;</code></a>로 표시한다. 
  </p>
  
  <p> 예제 코드: </p>
  <code><pre>
    &lt;ol&gt;
        &lt;li&gt; 숫자1 &lt;/li&gt;
        &lt;li&gt; 숫자2 &lt;/li&gt;
        나머지
        숫자
        없음
    &lt;/ol&gt;
  </pre></code>
  <p> 실행 결과: </p>
  <ol>
    <li> 숫자1 </li>
    <li> 숫자2 </li>
    나머지
    숫자
    없음
  </ol>

  <h3>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl">
      <code>&lt;dl&gt;</code></a>로 기호 없는 리스트를 만든다. 
  </h3>

  <p> 리스트의 내용 중 들여쓰기를 하지 않을 부분은 
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt">
      <code>&lt;dt&gt;</code></a>로 표시한다. 
  </p>

  <p> 리스트의 내용 중 들여쓰기를 할 부분은 
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd">
      <code>&lt;dd&gt;</code></a>로 표시한다. 
  </p>

  <p> 예제 코드: </p>
  <code><pre>
    &lt;dl&gt;
        &lt;dt&gt; 들여쓰기 없음 &lt;/dt&gt;
        &lt;dd&gt; 들여쓰기 있음 &lt;/dd&gt;
        나머지
        들여쓰기
        없음
    &lt;/ol&gt;
  </pre></code>
  <p> 실행 결과: </p>
  <ol>
    <dt> 들여쓰기 없음 </dt>
    <dd> 들여쓰기 있음 </dd>
    나머지
    들여쓰기
    없음
  </ol>

  <h1> ML 2일차 - MNIST 숫자 손글씨 이미지 </h1>
  <p> 공부한 자료: 
    <a href="https://www.pnas.org/doi/full/10.1073/pnas.1912334117">
      Controversial stimuli: Pitting neural networks against each other as models of human cognition
    </a>, Tal Golan, Prashant C. Raju, Nikolaus Kriegeskorte, <i>PNAS</i>, 2020
  </p>

  <p> 
    인간의 인식과 비슷한 딥러닝 모델을 만들기 위해 모델간에 다르게 예측하는 이미지를 생성해본다. 
  </p>

  <p> 
    MAD (maximum differentiation) 경쟁: 이미지 소스를 변형하는 방법.
    두 모델이 있을 때, 한 모델의 반응을 고정하고 다른 모델의 반응이 높아지거나 낮아지는
    방향으로 변형. 
  </p>

  <p>
    MNIST 이미지를 분류할 수 있는 모델 이름: small VGG, small VGG-, Wen PCN-E4, 
    Madry l_inf, Madry l_2, CapsuleNet Recon, Gaussian KDE, Schott ABS
  </p>

  <h1> C2y standard 7일차 </h1>
  <p> 공부한 자료: <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3435.pdf">International Standard Organization의 C23 standard</a> </p>
  <h2> Pix </h2>

  <p> 7.17.6 원자 정수 타입 </p>
  <p> 7.17.7 원자 정수 타입의 연산 </p>
  <p> 7.17.8 원자 플래그 타입과 연산 </p>
  <p> 7.18 비트와 바이트 &lt;stdbit.h&gt; </p>
  <p> 7.18.1 일반 </p>
  <p> 7.18.2 엔디안 </p>
  <p> 7.18.3 앞의 0 개수 세기 </p>
  <p> 7.18.4 앞의 1 개수 세기 </p>
  <p> 7.18.5 뒤의 0 개수 세기 </p>
  <p> 7.18.6 뒤의 1 개수 세기 </p>
  <p> 7.18.7 첫 0 </p>
  <p> 7.18.8 첫 1 </p>
  <p> 7.18.9 끝 0 </p>
  <p> 7.18.10 끝 1 </p>
  <p> 7.18.11 0 개수 세기 </p>
  <p> 7.18.12 1 개수 세기 </p>
  <p> 7.18.13 비트 하나 확인 </p>
  <p> 7.18.14 비트 폭 </p>
  <p> 7.18.15 비트 내림 </p>
  <p> 7.18.16 비트 올림 </p>
  <p> 7.18.17 왼쪽으로 회전 </p>
  <p> 7.18.18 오른쪽으로 회전 </p>
  <p> 7.18.19 8비트 메모리 거꾸로 돌리기 </p>
  <p> 7.18.20 정확한 폭의 8비트 메모리 거꾸로 돌리기 </p>
  <p> 7.18.21 엔디안을 반영한 8비트 불러오기 </p>
  <p> 7.18.22 엔디안을 반영한 8비트 저장 </p>
  <p> 7.19 논리 타입과 값 &lt;stdbool.h&gt; </p>
  <p> 7.20 확인된 정수 산수 &lt;stdckdint.h&gt; </p>
  <p> 7.20.1 일반 </p>
  <p> 7.20.2 체크된 정수 연산 타입 - 범용 매크로 </p>
  <p> 7.21 흔한 정의들 &lt;stddef.h&gt; </p>
  <p> 7.21.1 일반 </p>
  <p> 7.21.2 <code>unreachable</code> 매크로 </p>
  <p> 7.21.3 <code>nullptr_t</code> 타입 </p>
  <p> 7.22 정수 타입 &lt;stdint.h&gt; </p>
  <p> 7.22.1 일반 </p>
  <p> 7.22.2 정수 타입 </p>
  <p> 7.22.3 폭이 지정된 정수 타입의 폭 </p>
  <p> 7.22.4 다른 정수 타입의 폭 </p>
  <p> 7.22.5 정수 타입 상수 매크로 </p>

  <h2> Px </h2>
  <p> 7.23 입출력 &lt;stdio.h&gt; </p>
  <p> 7.23.1 도입 </p>
  <p> 7.23.2 스트림 </p>
  <p> 7.23.3 파일 </p>
  <p> 7.23.4 파일에서의 연산 </p>
  <p> 7.23.5 파일 접근 함수 </p>
  <p> 7.23.6 포맷팅된 입출력 함수 </p>
  <p> 7.23.7 문자 입출력 함수 </p>
  <p> 7.23.8 직접 입출력 함수 </p>
  <p> 7.23.9 파일에서 위치를 잡는 함수 </p>
  <p> 7.23.10 에러를 처리하는 함수 </p>
  <p> 7.24 일반적인 기능 제공 &lt;stdlib.h&gt; </p>
  <p> 7.24.1 일반 </p>
  <p> 7.24.2 숫자 변환 함수 </p>
  <p> 7.24.3 유사 랜덤 수열 생성 함수 </p>
  <p> 7.24.4 메모리 관리 함수 </p>
  <p> 7.24.5 환경과 통신 </p>
  <p> 7.24.6 검색 및 정렬 기능 </p>
  <p> 7.24.7 정수 산수 함수 </p>
  <p> 7.24.8 멀티바이트/확장 문자 변환 함수 </p>
  <p> 7.24.9 멀티바이트/확장 문자열 변환 함수 </p>
  <p> 7.24.10 메모리 정렬 </p>
  <p> 7.25 텍스트 인코딩/디코딩 기능 &lt;stdmchar.h&gt; </p>
  <p> 7.25.1 일반 </p>
  <p> 7.25.2 한 단위 크기 변환 함수 </p>
  <p> 7.25.3 여러 단위 크기 변환 함수 </p>
  <p> 7.26 _Noreturn &lt;stdnoreturn.h&gt; </p>
  <p> 7.27 문자열 처리 &lt;string.h&gt; </p>
  <p> 7.27.1 문자열 함수 전통 </p>
  <p> 7.27.2 복사 함수 </p>
  <p> 7.27.3 이어붙이기 함수 </p>
  <p> 7.27.4 비교 함수 </p>
  <p> 7.27.5 검색 함수 </p>
  <p> 7.27.6 기타 함수 </p>
  <p> 7.28 타입-범용 수학 &lt;tgmath.h&gt; </p>
  <p> 7.29 쓰레드 &lt;threads.h&gt; </p>
  <p> 7.29.1 도입 </p>
  <p> 7.29.2 초기화 함수 </p>
  <p> 7.29.3 조건 변수 함수 </p>

  <h2> Pxi </h2>
  
  <p> 7.29.4 뮤텍스 함수 </p>
  <p> 7.29.5 쓰레드 함수 </p>
  <p> 7.29.6 쓰레드 지정 저장 함수 </p>
  <p> 7.30 날짜 및 시간 &lt;time.h&gt; </p>
  <p> 7.30.1 시간의 구성 </p>
  <p> 7.30.2 시간 조작 함수 </p>
  <p> 7.30.3 시간 변환 함수 </p>
  <p> 7.31 유니코드 기능 &lt;uchar.t&gt; </p>
  <p> 7.31.1 일반 </p>
  <p> 7.31.2 재시작 가능한 멀티바이트/확장 문자 변환 함수 </p>
  <p> 7.32 멀티바이트 및 확장 문자 관련 추가 기능 &lt;wchar.h&gt; </p>
  <p> 7.32.1 도입 </p>
  <p> 7.32.2 포맷팅된 확장 문자 입출력 함수 </p>
  <p> 7.32.3 확장 문자 입출력 함수 </p>
  <p> 7.32.4 범용 확장 문자열 기능 </p>
  <p> 7.32.4.1 일반 </p>
  <p> 7.32.4.2 확장된 문자열 숫자 변환 함수 </p>
  <p> 7.32.4.3 확장된 문자열 복사 함수 </p>
  <p> 7.32.4.4 확장된 문자열 이어붙이기 함수 </p>
  <p> 7.32.4.5 확장된 문자열 비교 함수 </p>
  <p> 7.32.4.6 확장된 문자 검색 함수 </p>
  <p> 7.32.4.7 기타 함수 </p>
  <p> 7.32.5 확장된 문자 시간 변환 함수 </p>
  <p> 7.32.6 멀티바이트/확장된 문자 변환 관련 추가 기능 </p>
  <p> 7.32.6.1 일반 </p>
  <p> 7.32.6.2 단일바이트/확장 문자 변환 함수</p>
  <p> 7.32.6.3 변환 상태 함수 </p>
  <p> 7.32.6.4 재시작 가능한 멀티바이트/확장 문자 변환 함수 </p>
  <p> 7.32.6.5 재시작 가능한 멀티바이트/확장 문자열 변환 함수 </p>
  <p> 7.33 확장 문자 분류 및 매핑 기능 &lt;wctype.h&gt; </p>
  <p> 7.33.1 도입 </p>
  <p> 7.33.2 확장 문자 분류 기능 </p>
  <p> 7.33.2.1 일반 </p>
  <p> 7.33.2.2 확장 문자 분류 함수 </p>
  <p> 7.33.2.3 확장 문자 분류 관련 추가 함수 </p>
  <p> 7.33.3 확장 문자 대소문자 매핑 기능 </p>
  <p> 7.33.3.1 확장 문자 대소문자 매핑 함수 </p>
  <p> 7.33.3.2 확장 문자 대소문자 매핑 관련 추가 함수 </p>
  <p> 7.34 미래 라이브러리 방향 </p>
  <p> 7.34.1 일반 </p>

  <h2> Pxii </h2>

  <p> 7.34.2 복소 산수 &lt;complex.h&gt; </p>
  <p> 7.34.3 문자 처리 &lt;ctype.h&gt; </p>
  <p> 7.34.4 에러 &lt;errno.h&gt; </p>
  <p> 7.34.5 부동소수점 환경 &lt;fenv.h&gt; </p>
  <p> 7.34.6 부동소수점 타입의 특성 &lt;float.h&gt; </p>
  <p> 7.34.7 정수 타입의 포맷 변환 &lt;inttypes.h&gt; </p>
  <p> 7.34.8 지역화 &lt;locale.h&gt; </p>
  <p> 7.34.9 수학 &lt;math.h&gt; </p>
  <p> 7.34.10 신호 처리 &lt;signal.h&gt; </p>
  <p> 7.34.11 원자 &lt;stdatomic.h&gt; </p>
  <p> 7.34.12 논리 타입과 값 &lt;stdbool.h&gt; </p>
  <p> 7.34.13 비트 및 바이트 기능 &lt;stdbit.h&gt; </p>
  <p> 7.34.14 확인된 산수 함수 &lt;stdckdint.h&gt; </p>
  <p> 7.34.15 정수 타입 &lt;stdint.h&gt; </p>
  <p> 7.34.16 입출력 &lt;stdio.h&gt; </p>
  <p> 7.34.17 일반 기능 &lt;stdlib.h&gt; </p>
  <p> 7.34.18 문자열 처리 &lt;string.h&gt; </p>
  <p> 7.34.19 날짜와 시간 &lt;time.h&gt; </p>
  <p> 7.34.20 쓰레드 &lt;threads.h&gt; </p>
  <p> 7.34.21 멀티바이트 및 확장 문자 관련 추가 기능 &lt;wchar.h&gt; </p>
  <p> 7.34.22 확장 문자 분류 및 매핑 기능 &lt;wctype.h&gt; </p>

  <p> Annex A (정보) 언어 문법 요약 </p>
  <p> Annex B (정보) 라이브러리 요약 </p>
  <p> Annex C (정보) 시퀀스 포인트 </p>
  <p> Annex D (정보) 식별자의 보편적인 이름 </p>
  <p> Annex E (정보) 구현의 한계 </p>
  <p> Annex F (규범) ISO/IEC 60559 부동소수점 산수 </p>
  <p> Annex G (규범) ISO/IEC 60559-호환 복소수 산수 </p>
  <p> Annex H (규범) ISO/IEC 60559 교환 및 추가 타입 </p>
  <p> Annex I (정보) 일반적인 경고문 </p>
  <p> Annex J (정보) 이식성 이슈 </p>
  <p> Annex K (규범) 경계 확인 인터페이스 </p>
  <p> Annex L (정보) 분석 가능 </p>

  <h2> Pxiii </h2>

  <p> Annex M (정보) 변경 내용 기록 </p>
  <p> 참고 문헌 </p>
  <p> 차례 </p>

  <h1> PNG 파일 구조 </h1>
  
  <p>
    공부한 자료 : 
    <a href="http://www.libpng.org/pub/png/spec/1.2/png-1.2-pdg.html#Compression">
      PNG (Portable Network Graphics) specification v1.2
    </a>
  </p>

  <h3> 3장 파일 구조 </h3>

  <p> 3.1 PNG 파일 시그니처 </p>
  <p> 모든 PNG 파일의 첫 여덟 바이트는 다음 십진수 값을 가진다: </p>
  <code> 137 80 78 71 13 10 26 10 </code>
  <p> 이어서 IHDR 뭉치를 시작으로 하는 뭉치들이 나오고, IEND 뭉치로 끝난다. </p>

  <p> 3.2 뭉치의 구성 </p>
  <p> 모든 뭉치는 네 파트로 이뤄져있다. </p>
  <p> 길이: 뭉치의 데이터 파트에 몇 바이트가 있는지를 4바이트 unsigned int로 나타낸다. </p>
  <p> 뭉치 타입: 4바이트 뭉치 타입 코드로 영어 대소문자의 아스키코드로 정해진다. </p>
  <p> 데이터: 크기는 0바이트일 수도 있고 제한이 없다. 타입에 적절한 데이터 바이트다. </p>
  <p> CRC: 뭉치 타입 파트와 데이터 파트에 대해 값을 확인해주는 숫자다. </p>

  <h3> 4장 뭉치 규격 </h3>
  <p> 적합한 PNG 파일은 IHDR 뭉치 하나, 하나 이상의 IDAT 뭉치, IEND 뭉치 하나가 있어야 한다. </p>
  <p> IHDR 이미지 헤더 </p>
  <p> IHDR 뭉치는 반드시 가장 먼저 나와야 한다. 내용은: </p>
  <pre><code>
    폭        4바이트
    높이      4바이트
    비트깊이  1바이트
    색깔종류  1바이트
    압축방법  1바이트
    필터방법  1바이트
    순서변경  1바이트 
  </code></pre>
  <p> 
    폭과 높이는 이미지 크기 관련 값이고, 픽셀 단위다. 0은 부적합한 값이다. 
    비트깊이는 샘플 또는 팔레트 색깔당 몇비트를 쓸 것인지를 정한다. 
    색깔종류는 팔레트를 쓸지, 색깔을 쓸지, 투명도를 쓸지를 정한다. 
    색깔종류에 따라 가능한 비트깊이 값들이 다르다. 
    압축방법과 필터방법은 현재 0만 지원된다. 
    순서변경은 0을 하면 해당 없고, 1을 하면 아담7 방법으로 픽셀이 저장되는 순서를 바꾼다. 
  </p>

  <p> IDAT 이미지 데이터 </p>
  <p> IDAT 뭉치의 데이터는 다음과 같이 만든다. </p>
  <p> 이미지의 첫번째 줄부터, 왼쪽 픽셀부터 차례대로 색깔 값을 늘어놓는다. </p>
  <p> 트루컬러 픽셀의 경우 빨간색, 초록색, 파란색 순서로 나온다. </p>
  <p> 각 줄에 필터를 적용한다. 필터를 적용하지 않을 때는 각 줄의 앞에 0을 붙인다.</p>
  <p> 압축 방법에 따라 데이터를 압축한다. </p>

  <p> IEND 이미지 끝 </p>
  <p> IEND 뭉치는 가장 마지막에 나와야 한다. PNG의 끝을 표시하며, 데이터는 없다. </p>

  <h3> 5장 압축 방법 </h3>
  <p> PNG 안에 있는 데이터는 zlib 포맷으로 저장되어 있다. zlib 포맷은:</p>
  <code><pre>
    압축 방법/플래그 코드
    추가 플래그/확인 비트 
    압축된 데이터 
    체크 값
  </pre></code>
  <p> zlib 포맷에 대한 자세한 자세한 내용은 zlib 규격[RFC-1950]에 있다. </p>
  <p> 압축 방법에 대한 자세한 내용은 압축 규격[RFC-1951]에 있다. </p>

  <h3> 15장 CRC 샘플 코드 </h3>
  <pre><code>
    unsigned long crc_table[256];
    int crc_table_computed = 0;
    void make_crc_table(void)
    {
      unsigned long c;
      int n, k;

      for (n = 0; n &lt; 256; n++) {
        c = (unsigned long) n;
        for (k = 0; k &lt; 8; k++) {
          if (c & 1)
            c = 0xedb88320L ^ (c >> 1);
          else
            c = c >> 1;
        }
        crc_table[n] = c;
      }
      crc_table_computed = 1;
    }

    unsigned long update_crc(unsigned long crc, unsigned char *buf, int len)
    {
      unsigned long c = crc;
      int n;

      if (!crc_table_computed)
        make_crc_table();
      for (n = 0; n &lt; len; n++) {
        c = crc_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
      }
      return c;
    }

    unsigned long crc(unsigned char *buf, int len)
    {
      return update_crc(0xffffffffL, buf, len) ^ 0xffffffffL;
    }
  </code></pre>

  <h1> ZLIB 압축 데이터 포맷 </h1>
  
  <p>
    공부한 자료 : 
    <a href="https://www.rfc-editor.org/rfc/rfc1950">
      ZLIB Compressed Data Format Specification v3
    </a>
  </p>

  <h3> 2.2 데이터 포맷 </h3>

  <p> zlib은 다음과 같은 구조로 되어 있다: </p>
  <p> |CMF|FLG|...데이터...|ADLER32| </p>

  <p> CMF는 비트 0부터 3까지: CM (압축 방법), 비트 4부터 7까지: CINFO (압축 정보)다. </p>
  <p> CM = 8이 PNG에서 쓰인다. </p>
  <p> CINFO는 2를 지수로 한 윈도우 크기의 로그 빼기 팔이다. CINFO=7이 32K. </p>

  <p> FLG는 다음과 같이 구성되어있다. </p>
  <pre><code>
    bits 0 to 4   FCHECK (CMF와 FLG에 대한 확인 비트)
    bit 5         FDICT (사전을 쓸 것인지 여부)
    bits 6 to 7   FLEVEL (압축된 정도)
  </code></pre>

  <p> FCHECK는 CMF와 FLG를 합친 것 (CMF*256 + FLG)이 31의 배수가 되게 하는 값이다. </p>

  <p> FDICT는 PNG에서 0으로 설정한다. </p>

  <p> FLEVEL은 압축을 얼만큼 했는지를 0 (최소) 부터 3 (최대) 까지로 나타낸다. </p>

  <p> ADLER32는 압축되지 않은 데이터에 대한 확인 값이다. </p>

  <h3> 부록: ADLER32 예제 코드 </h3>

  <pre><code>
    #define BASE 65521

    unsigned long adler = 1L;

    while (read_buffer(buffer, length) != EOF) {
      adler = update_adler32(adler, buffer, length);
    }

    unsigned long update_adler32(unsigned long alder, unsigned char *buf, int len)
    {
      unsigned long s1 = adler & 0xffff;
      unsigned long s2 = (adler >> 16) & 0xffff;
      int n;

      for (n = 0; n &lt; len; n++) {
        s1 = (s1 + buf[n]) % BASE;
        s2 = (s2 + s1)     % BASE;
      }
      return (s2 &lt;&lt; 16);
    }

    unsigned long adler32(unsigned char *buf, int len)
    {
      return update_adler32(1L, buf, len);
    }
  </code></pre>

  <h1> DEFLATE 압축 데이터 </h1>

  <p>
    공부한 자료 : 
    <a href="https://www.rfc-editor.org/rfc/rfc1951">
      DEFLATE Compressed Data Format Specification 
    </a>
  </p>

  <h3> 3.2.3 블록 포맷의 자세한 내용 </h3>

  <p> 모든 압축 데이터 블록은 3개 헤더 비트로 시작한다. 다음과 같다: </p>

  <pre><code>
    첫번째 비트     BFINAL
    두번째 비트     BTYPE 
  </code></pre>

  <p> BFINAL은 마지막 블록에서만 1이 된다. </p>

  <p> BTYPE은 01일 때 정적 Huffman 코드로 압축되어있음을 의미한다. </p>

  <p> 모든 압축 데이터는 다음 알고리즘에 따라서 디코딩 된다. </p>

  <pre><code>
    do 
      블록 헤더 읽기
      if 압축되어있지 않은 경우 
        현재 처리중인 바이트에서 남은 비트를 스킵한다. 
        LEN과 NLEN을 읽는다. 
        LEN 바이트를 출력으로 복사한다. 
      else 
        if 동적 Huffman 코드로 압축되었을 때 
          코드 트리에 따라서 읽는다. 
        else 
          loop (end-of-block을 인식)
            값을 디코딩 해서 읽어온다. 
            if 값 &lt; 256 
              출력에 값을 복사한다. 
            else
              if 읽은 값이 end-of-block (256)
                loop를 빠져나간다. 
              else 
                정해진 규칙에 따라 앞에서 복사해온다. 
          loop 끝 
    while 마지막 블록이 아님 
  </code></pre>

  <h3> 3.2.5 압축된 블록 </h3>

  <p> 0 ~ 255는 바이트 값을 의미한다. 256은 블록의 끝을 의미한다. 
    257 ~ 285에는 특별한 규칙이 있다. 
  </p>

  <h3> 3.2.6 정적 Huffman 코드 </h3>

  <p> 다음과 같이 코딩 되어 있다. </p>

  <pre><code>
    바이트 값       비트수      코드 
      0 - 143         8           00110000 - 10111111
    144 - 255         9           110010000 - 111111111
    256 - 279         7           0000000 - 0010111   
    280 - 287         8           11000000 - 11000111 
  </code></pre>
</html>
